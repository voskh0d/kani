<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Kani Rust Verifier</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install-guide.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">1.2.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kani-single-file.html"><strong aria-hidden="true">1.2.1.</strong> On a single file</a></li><li class="chapter-item expanded "><a href="cargo-kani.html"><strong aria-hidden="true">1.2.2.</strong> On a package</a></li></ol></li><li class="chapter-item expanded "><a href="verification-results.html"><strong aria-hidden="true">1.3.</strong> Verification results</a></li></ol></li><li class="chapter-item expanded "><a href="kani-tutorial.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial-first-steps.html"><strong aria-hidden="true">2.1.</strong> First steps</a></li><li class="chapter-item expanded "><a href="tutorial-kinds-of-failure.html"><strong aria-hidden="true">2.2.</strong> Failures that Kani can spot</a></li><li class="chapter-item expanded "><a href="tutorial-loop-unwinding.html"><strong aria-hidden="true">2.3.</strong> Loop unwinding</a></li><li class="chapter-item expanded "><a href="tutorial-nondeterministic-variables.html"><strong aria-hidden="true">2.4.</strong> Nondeterministic variables</a></li></ol></li><li class="chapter-item expanded "><a href="application.html"><strong aria-hidden="true">3.</strong> Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool-comparison.html"><strong aria-hidden="true">3.1.</strong> Comparison with other tools</a></li><li class="chapter-item expanded "><a href="tutorial-real-code.html"><strong aria-hidden="true">3.2.</strong> Where to start on real code</a></li></ol></li><li class="chapter-item expanded "><a href="dev-documentation.html"><strong aria-hidden="true">4.</strong> Developer documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cbmc-hacks.html"><strong aria-hidden="true">4.1.</strong> Working with CBMC</a></li><li class="chapter-item expanded "><a href="rustc-hacks.html"><strong aria-hidden="true">4.2.</strong> Working with rustc</a></li><li class="chapter-item expanded "><a href="cheat-sheets.html"><strong aria-hidden="true">4.3.</strong> Command cheat sheets</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">4.4.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="regression-testing.html"><strong aria-hidden="true">4.4.1.</strong> Regression testing</a></li><li class="chapter-item expanded "><a href="bookrunner.html"><strong aria-hidden="true">4.4.2.</strong> Book runner</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">5.</strong> Limitations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="undefined-behaviour.html"><strong aria-hidden="true">5.1.</strong> Undefined behaviour</a></li><li class="chapter-item expanded "><a href="rust-feature-support.html"><strong aria-hidden="true">5.2.</strong> Rust feature support</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-feature-support/intrinsics.html"><strong aria-hidden="true">5.2.1.</strong> Intrinsics</a></li><li class="chapter-item expanded "><a href="rust-feature-support/unstable.html"><strong aria-hidden="true">5.2.2.</strong> Unstable features</a></li></ol></li><li class="chapter-item expanded "><a href="overrides.html"><strong aria-hidden="true">5.3.</strong> Overrides</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Kani Rust Verifier</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Kani is an open-source verification tool that uses automated reasoning to analyze Rust programs.
Kani is particularly useful for verifying unsafe code in Rust, where many of the Rust’s usual guarantees are no longer checked by the compiler.
Some example properties you can prove with Kani include memory safety properties (e.g., null pointer dereferences, use-after-free, etc.), the absence of certain runtime errors (i.e., panics), and the absence of some types of unexpected behavior (e.g., arithmetic overflows).
Kani can also prove custom properties provided in the form of user-specified assertions.</p>
<p>Kani uses proof harnesses to analyze programs. Proof harnesses are similar to test harnesses, especially property-based test harnesses.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project Status</a></h2>
<p>Kani is currently under active development. Releases are published <a href="https://github.com/model-checking/kani/releases">here</a>.
There is support for a fair amount of Rust language features, but not all (e.g., concurrency).
Please see <a href="./rust-feature-support.html">Limitations - Rust feature support</a> for a detailed list of supported features.</p>
<p>Kani usually synchronizes with the nightly release of Rust every two weeks, and so is generally up-to-date with the latest Rust language features.</p>
<p>If you encounter issues when using Kani, we encourage you to <a href="https://github.com/model-checking/kani/issues/new/choose">report them to us</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>To install the latest version of Kani, run:</p>
<pre><code class="language-bash">cargo install --locked kani-verifier
cargo-kani setup
</code></pre>
<p>This will build and place in <code>~/.cargo/bin</code> (in a typical environment) the <code>kani</code> and <code>cargo-kani</code> binaries.
The second step (<code>cargo-kani setup</code>) will download the Kani compiler and other necessary dependencies (and place them under <code>~/.kani/</code>).</p>
<p>Currently, only two platforms are supported:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
</ul>
<p>The following must already be installed:</p>
<ul>
<li><strong>Python version 3.8 or greater</strong> and the package installer pip.</li>
<li>Rust installed via <code>rustup</code></li>
<li><code>ctags</code> is required for Kani's <code>--visualize</code> option to work correctly.</li>
</ul>
<h1 id="installing-an-older-version-of-kani"><a class="header" href="#installing-an-older-version-of-kani">Installing an older version of Kani</a></h1>
<pre><code class="language-bash">cargo install --lock kani-verifier --version &lt;VERSION&gt;
cargo-kani setup
</code></pre>
<h1 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h1>
<p>In general, the following dependencies are required.</p>
<blockquote>
<p><strong>NOTE</strong>: These dependencies may be installed by running the CI scripts shown
below and there's no need to install them separately, for their respective
OS.</p>
</blockquote>
<ol>
<li>Cargo installed via <a href="https://rustup.rs/">rustup</a></li>
<li><a href="https://github.com/diffblue/cbmc">CBMC</a> (&gt;= 5.58.1)</li>
<li><a href="https://github.com/awslabs/aws-viewer-for-cbmc">CBMC Viewer</a> (&gt;= 2.10)</li>
</ol>
<p>Kani has been tested in <a href="install-guide.html#install-dependencies-on-ubuntu">Ubuntu</a> and <a href="install-guide.html##install-dependencies-on-macos">macOS</a> platforms.</p>
<h2 id="install-dependencies-on-ubuntu"><a class="header" href="#install-dependencies-on-ubuntu">Install dependencies on Ubuntu</a></h2>
<p>Support is available for Ubuntu 18.04 and 20.04.
The simplest way to install dependencies (especially if you're using a fresh VM)
is following our CI scripts:</p>
<pre><code># git clone git@github.com:model-checking/kani.git
git clone https://github.com/model-checking/kani.git
cd kani
git submodule update --init
./scripts/setup/ubuntu/install_deps.sh
./scripts/setup/ubuntu/install_cbmc.sh
./scripts/setup/install_viewer.sh 3.2
./scripts/setup/install_rustup.sh
# If you haven't already:
source $HOME/.cargo/env
</code></pre>
<h2 id="install-dependencies-on-macos"><a class="header" href="#install-dependencies-on-macos">Install dependencies on macOS</a></h2>
<p>Support is available for macOS 10.15. You need to have <a href="https://brew.sh/">Homebrew</a> installed already.</p>
<pre><code># git clone git@github.com:model-checking/kani.git
git clone https://github.com/model-checking/kani.git
cd kani
git submodule update --init
./scripts/setup/macos-10.15/install_deps.sh
./scripts/setup/macos-10.15/install_cbmc.sh
./scripts/setup/install_viewer.sh 3.2
./scripts/setup/install_rustup.sh
# If you haven't already:
source $HOME/.cargo/env
</code></pre>
<h2 id="build-and-test-kani"><a class="header" href="#build-and-test-kani">Build and test Kani</a></h2>
<p>Build the Kani package:</p>
<pre><code>cargo build --workspace
</code></pre>
<p>Then, optionally, run the regression tests:</p>
<pre><code>./scripts/kani-regression.sh
</code></pre>
<p>This script has a lot of noisy output, but on a successful run you'll see:</p>
<pre><code>All Kani regression tests completed successfully.
</code></pre>
<h2 id="try-running-kani"><a class="header" href="#try-running-kani">Try running Kani</a></h2>
<p>Add the Kani scripts to your path:</p>
<pre><code class="language-bash">export PATH=$(pwd)/scripts:$PATH
</code></pre>
<p>Create a test file:</p>
<pre><code class="language-rust">// File: test.rs
#[kani::proof]
fn main() {
    assert!(1 == 2);
}
</code></pre>
<p>Run Kani on the single file:</p>
<pre><code>kani test.rs
</code></pre>
<p>You should get a result like this one:</p>
<pre><code>[...]
RESULTS:
Check 1: main.assertion.1
         - Status: FAILURE
         - Description: &quot;assertion failed: 1 == 2&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>Fix the test and you should see a result like this one:</p>
<pre><code>[...]
VERIFICATION:- SUCCESSFUL
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>If you're learning Kani for the first time, you may be interested in our <a href="kani-tutorial.html">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>At present, Kani can used in two ways:</p>
<ul>
<li><a href="./kani-single-file.html">On a single file</a> with the <code>kani</code> command.</li>
<li><a href="./cargo-kani.html">On a package</a> with the <code>cargo-kani</code> command.</li>
</ul>
<p>Running <a href="./kani-single-file.html">Kani on a single file</a> is quite useful for small
examples or projects that don't use <code>cargo</code>.</p>
<p>However, if you plan to integrate Kani in your projects, the recommended
approach is to use <a href="./cargo-kani.html">Kani on a package</a> because of its ability
to handle external dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-on-a-single-file"><a class="header" href="#usage-on-a-single-file">Usage on a single file</a></h1>
<p>For small examples or initial learning, it's very common to run Kani on just one source file.</p>
<p>The command line format for invoking Kani directly is the following:</p>
<pre><code>kani filename.rs [&lt;kani-args&gt;]*
</code></pre>
<p>For example,</p>
<pre><code>kani example.rs
</code></pre>
<p>runs Kani on all the proof harnesses from file <code>example.rs</code>.
A proof harness is simply a function with the <code>#[kani::proof]</code> annotation.</p>
<h2 id="common-arguments"><a class="header" href="#common-arguments">Common arguments</a></h2>
<p>The most common <code>kani</code> arguments are the following:</p>
<ul>
<li>
<p><code>--harness &lt;name&gt;</code>: By default, Kani checks all proof harnesses it finds. You
can switch to checking a single harness using this flag.</p>
</li>
<li>
<p><code>--default-unwind &lt;n&gt;</code>: Set a global upper <a href="./tutorial-loop-unwinding.html">loop
unwinding</a> bound on all loops. This can force
termination when CBMC tries to unwind loops indefinitely.</p>
</li>
<li>
<p><code>--output-format &lt;regular|terse|old&gt;</code>: By default (<code>regular</code>), Kani
post-processes CBMC's output to produce more comprehensible results. In
contrast, <code>terse</code> outputs only a summary of these results, and <code>old</code> forces
Kani to emit the original output from CBMC.</p>
</li>
<li>
<p><code>--visualize</code>: Generates an HTML report in the local directory accessible
through <code>report/html/index.html</code>. This report shows coverage information and
provides traces (i.e., counterexamples) for each failure found by Kani.</p>
</li>
</ul>
<p>Run <code>kani --help</code> to see a complete list of arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-on-a-package"><a class="header" href="#usage-on-a-package">Usage on a package</a></h1>
<p>Kani is also integrated with <code>cargo</code> and can be invoked from a crate directory as follows:</p>
<pre><code class="language-bash">cargo kani [&lt;kani-args&gt;]*
</code></pre>
<p><code>cargo kani</code> supports all <code>kani</code> arguments.</p>
<p><code>cargo kani</code> is the recommended approach for using Kani on a project, due to its
ability to handle external dependencies and the option add configurations via the <code>Cargo.toml</code> file.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Users can add a default configuration to the <code>Cargo.toml</code> file for running harnesses in a package.
Kani will extract any arguments from these sections:</p>
<ul>
<li><code>[kani]</code></li>
<li><code>[workspace.metadata.kani]</code></li>
<li><code>[package.metadata.kani]</code></li>
</ul>
<p>For example, say you want to set a loop unwinding bound of <code>5</code> for all the harnesses in a package.
You can achieve this by adding the following lines to the package's <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.kani]
flags = { default-unwind = &quot;5&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-results"><a class="header" href="#verification-results">Verification results</a></h1>
<p>Running Kani on a harness produces an output that includes a set of checks as
follows:</p>
<pre><code>RESULTS:
Check 1: example.assertion.1
         - Status: &lt;status&gt;
         - Description: &lt;description&gt;
         - Location: &lt;location&gt;
[...]
</code></pre>
<p>Kani determines the verification result for the harness based on the
result (i.e., <code>&lt;status&gt;</code>) of each individual check (also known as &quot;properties&quot;). If all
checks are successful then the overall verification result of the harness is successful. Otherwise the
verification fails, which indicates issues with the code under verification.</p>
<h2 id="check-results"><a class="header" href="#check-results">Check results</a></h2>
<p>The result (or <code>Status</code>) of a check in Kani can be one of the following:</p>
<ol>
<li><code>SUCCESS</code>: This indicates that the check passed (i.e., the property holds).
Note that in some cases, the property may hold <em>vacuously</em>. This can occur
because the property is unreachable, or because the harness is
<em>over-constrained</em>.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn success_example() {
    let mut sum = 0;
    for i in 1..4 {
        sum += i;
    }
    assert_eq!(sum, 6);
}
</code></pre>
<p>The output from Kani indicates that the assertion holds:</p>
<pre><code>Check 4: success_example.assertion.4
         - Status: SUCCESS
         - Description: &quot;assertion failed: sum == 6&quot;
</code></pre>
<ol start="2">
<li><code>FAILURE</code>: This indicates that the check failed (i.e., the property doesn't
hold). In this case, you can examine a trace by re-running with the
<code>--visualize</code> option.  This generates an HTML report with the trace
information.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn failure_example() {
    let arr = [1, 2, 3];
    assert_ne!(arr.len(), 3);
}
</code></pre>
<p>The assertion doesn't hold as Kani's output indicates:</p>
<pre><code>Check 2: failure_example.assertion.2
         - Status: FAILURE
         - Description: &quot;assertion failed: arr.len() != 3&quot;
</code></pre>
<ol start="3">
<li><code>UNREACHABLE</code>: This indicates that the check is unreachable (i.e., the
property holds <em>vacuously</em>). This occurs when there is no possible execution
trace that can reach the check's line of code.
This may be because the function that contains the check is unused, or because
the harness does not trigger the condition under which the check is invoked.
Kani currently checks reachability for the following assertion types:
<ol>
<li>Assert macros (e.g. <code>assert</code>, <code>assert_eq</code>, etc.)</li>
<li>Arithmetic overflow checks</li>
<li>Negation overflow checks</li>
<li>Index out-of-bounds checks</li>
<li>Divide/remainder-by-zero checks</li>
</ol>
</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn unreachable_example() {
    let x = 5;
    let y = x + 2;
    if x &gt; y {
        assert!(x &lt; 8);
    }
}
</code></pre>
<p>The output from Kani indicates that the assertion is unreachable:</p>
<pre><code>Check 2: unreachable_example.assertion.2
         - Status: UNREACHABLE
         - Description: &quot;assertion failed: x &lt; 8&quot;
</code></pre>
<ol start="4">
<li><code>UNDETERMINED</code>: This indicates that Kani was not able to conclude whether the
property holds or not. This can occur when the Rust program contains a construct
that is not currently supported by Kani. See
<a href="./rust-feature-support.html">Rust feature support</a> for Kani's current support of the
Rust language features.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn undetermined_example() {
    let mut x = 0;
    unsupp(&amp;mut x);
    assert!(x == 0);
}

#[feature(asm)]
fn unsupp(x: &amp;mut u8) {
    unsafe {
        std::arch::asm!(&quot;nop&quot;);
    }
}

</code></pre>
<p>The output from Kani indicates that the assertion is undetermined due to the
missing support for inline assembly in Kani:</p>
<pre><code>Check 2: undetermined_example.assertion.2
         - Status: UNDETERMINED
         - Description: &quot;assertion failed: x == 0&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<blockquote>
<p><strong>NOTE</strong>: This tutorial expects you to have followed the Kani <a href="./install-guide.html">installation instructions</a> first.</p>
</blockquote>
<p>This tutorial will step you through a progression from simple to moderately complex tasks with Kani.
It's meant to ensure you can get started, and see at least some simple examples of how typical proofs are structured.
It will also teach you the basics of &quot;debugging&quot; proof harnesses, which mainly consists of diagnosing and resolving non-termination issues with the solver.</p>
<p>You may also want to read the <a href="./application.html">Application</a> section to better
understand what Kani is and how it can be applied on real code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps"><a class="header" href="#first-steps">First steps</a></h1>
<p>Kani is unlike the testing tools you may already be familiar with.
Much of testing is concerned with thinking of new corner cases that need to be covered.
With Kani, all the corner cases are covered from the start, and the new concern is narrowing down the scope to something manageable for the checker.</p>
<p>Consider this first program (which can be found under <a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/first-steps-v1/"><code>first-steps-v1</code></a>):</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            panic!(&quot;Oh no, a failing corner case!&quot;);
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}
</code></pre>
<p>Think about the test harness you would need to write to test this function.
You would need figure out a whole set of arguments to call the function with that would exercise each branch.
You would also need to keep that test harness up-to-date with the code, in case some of the branches change.
And if this function was more complicated—for example, if some of the branches depended on global state—the test harness would be even more onerous to write.</p>
<p>We can try to property test a function like this, but if we're naive about it (and consider all possible <code>u32</code> inputs), then it's unlikely we'll ever find the bug.</p>
<pre><code class="language-rust">    proptest! {
        #![proptest_config(ProptestConfig::with_cases(10000))]
        #[test]
        fn doesnt_crash(x: u32) {
            estimate_size(x);
        }
    }
</code></pre>
<pre><code># cargo test
[...]
test tests::doesnt_crash ... ok
</code></pre>
<p>There's only 1 in 4 billion inputs that fail, so it's vanishingly unlikely the property test will find it, even with a million samples.</p>
<p>With Kani, however, we can use <code>kani::any()</code> to represent all possible <code>u32</code> values:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn main() {
    let x: u32 = kani::any();
    estimate_size(x);
}
</code></pre>
<pre><code># cargo kani
[...]
Runtime decision procedure: 0.00116886s

RESULTS:
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: &quot;Oh no, a failing corner case!&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>Kani has immediately found a failure.
Notably, we haven't had to write explicit assertions in our proof harness: by default, Kani will find a host of erroneous conditions which include a reachable call to <code>panic</code> or a failing <code>assert</code>.</p>
<h3 id="getting-a-trace"><a class="header" href="#getting-a-trace">Getting a trace</a></h3>
<p>By default, Kani only reports failures, not how the failure happened.
This is because, in its full generality, understanding how a failure happened requires exploring a full (potentially large) execution trace.
Here, we've just got some nondeterministic inputs up front, but that's something of a special case that has a &quot;simpler&quot; explanation (just the choice of nondeterministic input).</p>
<p>To see traces, run:</p>
<pre><code>kani --visualize src/main.rs
</code></pre>
<p>This command runs Kani and generates the HTML report in <code>report-main/html/index.html</code>.
Open the report with your preferred browser.
From this report, we can find the trace of the failure and filter through it to find the relevant line (at present time, an unfortunate amount of generated code is present in the trace):</p>
<pre><code>let x: u32 = kani::any();
x = 1023u
</code></pre>
<p>Here we're seeing the line of code and the value assigned in this particular trace.
Like property testing, this is just one example of a failure.
To find more, we'd presumably fix this issue and then re-run Kani.</p>
<h3 id="exercise-try-other-failures"><a class="header" href="#exercise-try-other-failures">Exercise: Try other failures</a></h3>
<p>We put an explicit panic in this function, but it's not the only kind of failure Kani will find.
Try a few other types of errors.</p>
<p>For example, instead of panicking we could try explicitly dereferencing a null pointer:</p>
<pre><code class="language-rust">unsafe { return *(0 as *const u32) };
</code></pre>
<p>Notably, however, the Rust compiler emits a warning here:</p>
<pre><code>warning: dereferencing a null pointer
  --&gt; src/lib.rs:10:29
   |
10 |    unsafe { return *(0 as *const u32) };
   |                    ^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed
   |
   = note: `#[warn(deref_nullptr)]` on by default
</code></pre>
<p>Still, it's just a warning, and we can run the code without test failures just as before.
But Kani still catches the issue:</p>
<pre><code>[...]
RESULTS:
[...]
Check 2: foo.pointer_dereference.1
         - Status: FAILURE
         - Description: &quot;dereference failure: pointer NULL&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p><strong>Can you find an example where the Rust compiler will not complain, and Kani will?</strong></p>
<details>
<summary>Click to show one possible answer</summary>
<pre><code>return 1 &lt;&lt; x;
</code></pre>
<p>Overflow (in addition, multiplication or, in this case, <a href="https://github.com/rust-lang/rust/issues/10183">bit-shifting by too much</a>) is also caught by Kani:</p>
<pre><code>RESULTS:
[...]
Check 3: foo.assertion.1
         - Status: FAILURE
         - Description: &quot;attempt to shift left with overflow&quot;

Check 4: foo.undefined-shift.1
         - Status: FAILURE
         - Description: &quot;shift distance too large&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
</details>
<h2 id="assertions-assumptions-and-harnesses"><a class="header" href="#assertions-assumptions-and-harnesses">Assertions, Assumptions, and Harnesses</a></h2>
<p>It seems a bit odd that we can take billions of inputs when our function only handles up to a few thousand.
Let's encode this fact about our function by asserting some reasonable bound on our input, after we've fixed our bug (code available under
<a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/first-steps-v2/"><code>first-steps-v2</code></a>):</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    assert!(x &lt; 4096);

    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            return 4;
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}
</code></pre>
<p>Now we've stated our previously implicit expectation: this function should never be called with inputs that are too big.
But if we attempt to verify this, we get a problem:</p>
<pre><code>[...]
RESULTS:
[...]
Check 3: final_form::estimate_size.assertion.1
         - Status: FAILURE
         - Description: &quot;assertion failed: x &lt; 4096&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>We intended this to be a precondition of calling the function, but Kani is treating it like a failure.
If we call this function with too large of a value, it will crash with an assertion failure.
But we know that, that was our intention.</p>
<p>This is the purpose of <em>proof harnesses</em>.
Much like property testing (which would also fail in this assertion), we need to set up our preconditions, call the function in question, then assert our postconditions.
Here's a revised example of the proof harness, one that now succeeds:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn verify_success() {
    let x: u32 = kani::any();
    kani::assume(x &lt; 4096);
    let y = estimate_size(x);
    assert!(y &lt; 10);
}
</code></pre>
<p>But now we must wonder if we've really fully tested our function.
What if we revise the function, but forget to update the assumption in our proof harness to cover the new range of inputs?</p>
<p>Fortunately, Kani is able to report a coverage metric for each proof harness.
Try running:</p>
<pre><code>kani --visualize src/main.rs --harness verify_success
open report-verify_success/html/index.html
</code></pre>
<p>The beginning of the report includes coverage information.
Clicking through to the file will show fully-covered lines in green.
Lines not covered by our proof harness will show in red.</p>
<ol>
<li>Try changing the assumption in the proof harness to <code>x &lt; 2048</code>. Now the harness won't be testing all possible cases.</li>
<li>Rerun <code>kani --visualize</code> on the file</li>
<li>Look at the report: you'll see we no longer have 100% coverage of the function.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="failures-that-kani-can-spot"><a class="header" href="#failures-that-kani-can-spot">Failures that Kani can spot</a></h1>
<p>In the <a href="./tutorial-first-steps.html">last section</a> we saw Kani spot two major kinds of failures: Assertions and panics.
If the proof harness allows some program execution that results in a panic, then Kani will report that as a failure.
In addition, we saw very briefly a couple of other kinds of failures: Null pointer dereferences and overflows.
In this section, we're going to expand on these additional checks, to give you an idea of what other problems Kani will find.</p>
<h2 id="bounds-checking-and-pointers"><a class="header" href="#bounds-checking-and-pointers">Bounds checking and pointers</a></h2>
<p>Rust is safe by default, and so includes dynamic (run-time) bounds checking where needed.
Consider this Rust code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/bounds_check.rs">here</a>):</p>
<pre><code class="language-rust">/// Wrap &quot;too-large&quot; indexes back into a valid range for the array
fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    if a.len() == 0 {
        return 0;
    }
    return a[i % a.len() + 1];
}
</code></pre>
<p>We can again write a simple property test against this code:</p>
<pre><code class="language-rust">    proptest! {
        #[test]
        fn doesnt_crash(i: usize, a: Vec&lt;u32&gt;) {
            get_wrapped(i, &amp;a);
        }
    }
</code></pre>
<p>This property test will immediately find the failing case because of this dynamic check.</p>
<p>But what if we change this function to use unsafe Rust?</p>
<pre><code class="language-rust">return unsafe { *a.get_unchecked(i % a.len() + 1) };
</code></pre>
<p>Now the error becomes invisible to this test:</p>
<pre><code># cargo test
[...]
test bounds_check::tests::doesnt_crash ... ok
</code></pre>
<p>But we're able to write a harness for this unsafe code:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn bound_check() {
    let size: usize = kani::any();
    kani::assume(size &lt; 4096);
    let index: usize = kani::any();
    let array: Vec&lt;u32&gt; = vec![0; size];
    get_wrapped(index, &amp;array);
}
</code></pre>
<p>If we run it with Kani:</p>
<pre><code class="language-bash">kani src/bounds_check.rs --harness bound_check
</code></pre>
<p>One of the checks fails. Also, notice there were many checks in the verification output.
This is a result of using the standard library <code>Vec</code> implementation, which means our harness actually used quite a bit of code, short as it looks.
Kani is inserting a lot more checks than appear as asserts in our code, so the output can be large.
Let's narrow that output down a bit:</p>
<pre><code># kani src/bounds_check.rs --harness bound_check | grep Failed
Failed Checks: dereference failure: pointer outside object bounds
</code></pre>
<p>Notice that, for Kani, this has gone from a simple bounds-checking problem to a pointer-checking problem.
Kani will check operations on pointers to ensure they're not potentially invalid memory accesses.
Any unsafe code that manipulates pointers will, as we see here, raise failures if its behavior is actually unsafe. </p>
<p>Consider trying a few more small exercises with this example:</p>
<ol>
<li>Exercise: Switch back to the normal/safe indexing operation and re-try Kani. What changes compared to the unsafe operation and why?
(Try predicting the answer, then seeing if you got it right.)</li>
<li>Exercise: <a href="./tutorial-first-steps.html#getting-a-trace">Remember how to get a trace from Kani?</a> Find out what inputs it failed on.</li>
<li>Exercise: Fix the error, run Kani, and see a successful verification.</li>
<li>Exercise: Try switching back to the unsafe code (now with the error fixed) and re-run Kani. It should still successfully verify.</li>
</ol>
<details>
<summary>Click to see explanation for exercise 1</summary>
<p>Having switched back to the safe indexing operation, Kani reports two failures:</p>
<pre><code># kani src/bounds_check.rs --harness bound_check | grep Failed
Failed Checks: index out of bounds: the length is less than or equal to the given index
Failed Checks: dereference failure: pointer outside object bounds
</code></pre>
<p>The first is Rust's implicit assertion for the safe indexing operation.
The second is Kani's check to ensure the pointer operation is actually safe.
This pattern (two checks for similar issues in safe Rust code) is common, and we'll see it again in the next section.</p>
</details>
<details>
<summary>Click to see explanation for exercise 2</summary>
<p>Having run <code>kani --visualize</code> and clicked on one of the failures to see a trace, there are three things to immediately notice:</p>
<ol>
<li>This trace is huge. Because the standard library <code>Vec</code> is involved, there's a lot going on.</li>
<li>The top of the trace file contains some &quot;trace navigation tips&quot; that might be helpful in navigating the trace.</li>
<li>There's a lot of generated code and it's really hard to just read the trace itself.</li>
</ol>
<p>To navigate this trace to find the information you need, we recommend searching for things you expect to be somewhere in the trace:</p>
<ol>
<li>Search the document for <code>kani::any</code> or <code>&lt;variable_of_interest&gt; =</code> such as <code>size =</code>.
We can use this to find out what example values lead to a problem.
In this case, where we just have a couple of <code>kani::any</code> values in our proof harness, we can learn a lot just by seeing what these are.
In this trace we find (and the values you get may be different):</li>
</ol>
<pre><code>Step 23: Function bound_check, File src/bounds_check.rs, Line 43
let size: usize = kani::any();
size = 0ul

Step 27: Function bound_check, File src/bounds_check.rs, Line 45
let index: usize = kani::any();
index = 0ul

Step 36: Function bound_check, File src/bounds_check.rs, Line 43
let size: usize = kani::any();
size = 2464ul

Step 39: Function main, File src/bounds_check.rs, Line 45
let index: usize = kani::any();
index = 2463ul
</code></pre>
<p>Try not to be fooled by the first assignments: we're seeing zero-initialization there.
Their values are overwritten by the later assignments.
You may see different values here, as it depends on the solver's behavior.</p>
<ol start="2">
<li>Try searching for &quot;failure:&quot;. This will be near the end of the document.
Now you can try reverse-searching for assignments to the variables involved.
For example, search upwards from the failure for <code>i =</code>.</li>
</ol>
<p>These two techniques should help you find both the nondeterministic inputs, and the values that were involved in the failing assertion.</p>
</details>
<h2 id="overflow-and-math-errors"><a class="header" href="#overflow-and-math-errors">Overflow and math errors</a></h2>
<p>Consider a different variant on the function above:</p>
<pre><code class="language-rust">fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    return a[i % a.len()];
}
</code></pre>
<p>We've corrected the out-of-bounds access, but now we've omitted the &quot;base case&quot;: what to return on an empty list.
Kani will spot this not as a bound error, but as a mathematical error: on an empty list the modulus operator (<code>%</code>) will cause a division by zero.</p>
<ol>
<li>Exercise: Try to run Kani on the above, to see what this kind of failure looks like.</li>
</ol>
<p>Rust also performs runtime safety checks for integer overflows, much like it does for bounds checks.
Consider this code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow.rs">here</a>):</p>
<pre><code class="language-rust">fn simple_addition(a: u32, b: u32) -&gt; u32 {
    return a + b;
}
</code></pre>
<p>A trivial function, but if we write a property test for it, we immediately find inputs where it fails, thanks to Rust's dynamic checks.
Kani will find these failures as well.
Here's the output from Kani:</p>
<pre><code># kani src/overflow.rs --harness add_overflow
[...]
RESULTS:
Check 1: simple_addition.assertion.1
         - Status: FAILURE
         - Description: &quot;attempt to add with overflow&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>This issue can be fixed using Rust's alternative mathematical functions with explicit overflow behavior.
For instance, instead of <code>a + b</code> write <code>a.wrapping_add(b)</code>.</p>
<h3 id="exercise-classic-overflow-failure"><a class="header" href="#exercise-classic-overflow-failure">Exercise: Classic overflow failure</a></h3>
<p>One of the classic subtle bugs that persisted in many implementations for a very long time is finding the midpoint in quick sort.
This often naively looks like this (code available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow_quicksort.rs">here</a>):</p>
<pre><code class="language-rust">fn find_midpoint(low: u32, high: u32) -&gt; u32 {
    return (low + high) / 2;
}
</code></pre>
<p>Kani immediately spots the bug in the above code.</p>
<ol>
<li>Exercise: Fix this function so it no longer overflows.
(Hint: depending on which approach you take, you may need to add the assumption that <code>high &gt; low</code> to your proof harness.
Don't add that right away, see what happens if you don't. Just keep it in mind.)</li>
<li>Exercise: Prove your new implementation actually finds the midpoint correctly by adding an assertion to the test harness.</li>
</ol>
<details>
<summary>Click to see solutions for these exercises</summary>
<p>A very common approach for resolving the overflow issue looks like this:</p>
<pre><code class="language-rust">return low + (high - low) / 2;
</code></pre>
<p>But if you naively try this (try it!), you'll find a new underflow error: <code>high - low</code> might result in a negative number, but has type <code>u32</code>.
Hence, the need to add an assumption that would make that impossible.
(Adding an assumption, though, means there's a new way to &quot;use it wrong.&quot; Perhaps we'd like to avoid that!)</p>
<p>After that, you might wonder how to &quot;prove your new implementation correct.&quot;
After all, what does &quot;correct&quot; even mean?
Often we're using a good approximation of correct, such as the equivalence of two implementations (often one much &quot;simpler&quot; than the other somehow).
Here's one possible assertion to make that obvious:</p>
<pre><code class="language-rust">assert!(result as u64 == (a as u64 + b as u64) / 2);
</code></pre>
<p>Since this implementation is just the original one, but cast to a wider unsigned integer type, it should have the same result but without overflowing.
When Kani tells us both of these methods yield the same exact result, that gives us additional confidence that we haven't overlooked something.</p>
</details>
<h2 id="failures-that-kani-cannot-spot"><a class="header" href="#failures-that-kani-cannot-spot">Failures that Kani cannot spot</a></h2>
<p>Check out <a href="./limitations.html">Limitations</a> for information on the checks that
Kani doesn't perform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-unwinding-and-bounds"><a class="header" href="#loops-unwinding-and-bounds">Loops, unwinding, and bounds</a></h1>
<p>Consider code like this (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/loops-unwinding/src/lib.rs">here</a>):</p>
<pre><code class="language-rust">fn initialize_prefix(length: usize, buffer: &amp;mut [u8]) {
    // Let's just ignore invalid calls
    if length &gt; buffer.len() {
        return;
    }

    for i in 0..=length {
        buffer[i] = 0;
    }
}
</code></pre>
<p>This code has an off-by-one error that only occurs on the last iteration of the loop (when called with an input that will trigger it).
We can try to find this bug with a proof harness like this:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
#[kani::unwind(11)]
fn main() {
    const LIMIT: usize = 10;
    let mut buffer: [u8; LIMIT] = [1; LIMIT];

    let length = kani::any();
    kani::assume(length &lt;= LIMIT);

    initialize_prefix(length, &amp;mut buffer);
}
</code></pre>
<p>When we run Kani on this, we run into an unfortunate result: non-termination.
This non-termination is caused by CBMC trying to unwind the loop an unlimited number of times.</p>
<blockquote>
<p><strong>NOTE</strong>: Presently, <a href="https://github.com/model-checking/kani/issues/493">due to a bug</a>, this is especially bad: we don't see any output at all.
Kani is supposed to emit some log lines that might give some clue that an infinite loop is occurring.
If Kani doesn't terminate, it's almost always the problem that this section covers.</p>
</blockquote>
<p>To verify programs like this, we need to do two things:</p>
<ol>
<li>Set an upper bound on the size of the problem.
We've actually already done part of this: our proof harness seems to be trying to set an upper limit of 10.</li>
<li>Tell Kani about this limit if it's not able to figure it out on its own.</li>
</ol>
<p>Bounding proofs like this means we may no longer be proving as much as we originally hoped.
Who's to say, if we prove everything works up to size 10, that there isn't a novel bug lurking, expressible only with problems of size 11+?
But, let's get back to the issue at hand.</p>
<p>We can &quot;make progress&quot; in our work by giving Kani a global bound on the problem size using the <code>--default-unwind &lt;bound&gt;</code> flag.
This flag puts a fixed upper bound on loop unwinding.
Kani will automatically generate verification conditions that help us understand if that bound isn't enough.
Let's start with a small unwinding value:</p>
<pre><code># kani src/lib.rs --default-unwind 1
Check 69: .unwind.0
         - Status: FAILURE
         - Description: &quot;unwinding assertion loop 0&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>This output is showing us two things:</p>
<ol>
<li>Kani tells us we haven't unwound enough. This is the failure of the &quot;unwinding assertion.&quot;</li>
<li>We aren't seeing other failures if we only unwind the loop once.
The execution can't progress far enough to reveal the bug we're interested in (which actually only happens in the last iteration of the loop).</li>
</ol>
<p>Doing an initial <code>--default-unwind 1</code> is generally enough to force termination, but often too little for verification.</p>
<p>We were clearly aiming at a size limit of 10 in our proof harness, so let's try a few things:</p>
<pre><code># kani src/lib.rs --default-unwind 10 | grep Failed
Failed Checks: unwinding assertion loop 0
</code></pre>
<p>A bound of 10 still isn't enough because we generally need to unwind one greater than the number of executed loop iterations:</p>
<pre><code># kani src/lib.rs --default-unwind 11 | grep Failed
Failed Checks: index out of bounds: the length is less than or equal to the given index
Failed Checks: dereference failure: pointer outside object bounds
Failed Checks: unwinding assertion loop 0
</code></pre>
<p>We're still not seeing the unwinding assertion failure go away!
This is because our error is really an off-by-one problem, we loop one too many times, so let's add one more:</p>
<pre><code># kani src/lib.rs --default-unwind 12 | grep Failed
Failed Checks: index out of bounds: the length is less than or equal to the given index
Failed Checks: dereference failure: pointer outside object bounds
</code></pre>
<p>Kani is now sure we've unwound the loop enough to verify our proof harness, and now we're seeing just the bound checking failures from the off-by-one error.</p>
<h2 id="unwinding-value-specification"><a class="header" href="#unwinding-value-specification">Unwinding value specification</a></h2>
<p>Kani allows three options to specify the unwind value for a particular harness:</p>
<ol>
<li>The unwind annotation <code>#[kani::unwind(&lt;num&gt;)]</code>. This sets the unwind value for the harness with the annotation. Example -</li>
</ol>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(3)]
fn proof_harness() {
[...]
}
</code></pre>
<ol start="2">
<li><code>--default-unwind</code> flag. This sets the global or default unwind value for the entire file/crate on which kani or cargo-kani is called. Example -</li>
</ol>
<pre><code>kani file.rs --default-unwind 3
</code></pre>
<ol start="3">
<li><code>--unwind</code> flag. This overrides any annotation and forces the harness to use the specified value. This needs to be used alongside <code>--harness</code> and sets the unwind value for the harness specified. Example -</li>
</ol>
<pre><code>kani file.rs --unwind 2 --harness proof_harness
</code></pre>
<h3 id="exercises--"><a class="header" href="#exercises--">Exercises -</a></h3>
<ol>
<li>Exercise: Fix the off-by-one bounds error and get Kani to verify successfully.</li>
<li>Exercise: After fixing the error, <code>--default-unwind 11</code> works. Why?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nondeterministic-variables"><a class="header" href="#nondeterministic-variables">Nondeterministic variables</a></h1>
<p>Kani is able to reason about programs and their execution paths by allowing users to assign nondeterministic (i.e., symbolic) values to  certain variables.
Since Kani is a bit-level model checker, this means that Kani considers that an unconstrained nondeterministic value represents all the possible bit-value combinations assigned to the variable's memory contents.</p>
<p>As a Rust developer, this sounds a lot like the <code>mem::transmute</code> operation, which is highly <code>unsafe</code>.
And that's correct.</p>
<p>In this tutorial, we will show how to:</p>
<ol>
<li>Safely use nondeterministic assignments to generate valid symbolic variables that respect Rust's type invariants.</li>
<li>Unsafely use nondeterministic assignments to generate unconstrained symbolic variables that do not respect Rust's type invariants.</li>
<li>Specify invariants for types that you define, enabling the creation of safe nondeterministic variables for those types.</li>
</ol>
<h2 id="safe-nondeterministic-variables"><a class="header" href="#safe-nondeterministic-variables">Safe nondeterministic variables</a></h2>
<p>Let's say you're developing an inventory management tool, and you would like to verify that your API to manage items is correct.
Here is a simple implementation of this API:</p>
<pre><code class="language-rust">use std::num::NonZeroU32;
use vector_map::VecMap;

type ProductId = u32;

pub struct Inventory {
    inner: VecMap&lt;ProductId, NonZeroU32&gt;,
}

impl Inventory {
    pub fn update(&amp;mut self, id: ProductId, new_quantity: NonZeroU32) {
        self.inner.insert(id, new_quantity);
    }

    pub fn get(&amp;self, id: &amp;ProductId) -&gt; Option&lt;NonZeroU32&gt; {
        self.inner.get(id).cloned()
    }
}
</code></pre>
<p>Now we would like to verify that, no matter which combination of <code>id</code> and <code>quantity</code>, a call to <code>Inventory::update()</code> followed by a call to <code>Inventory::get()</code> using the same <code>id</code> returns some value that's equal to the one we inserted:</p>
<pre><code class="language-rust">    #[kani::proof]
    pub fn safe_update() {
        // Create inventory variable.
        let mut inventory = Inventory { inner: VecMap::new() };

        // Create non-deterministic variables for id and quantity.
        let id: ProductId = kani::any();
        let quantity: NonZeroU32 = kani::any();
        assert!(quantity.get() != 0, &quot;NonZeroU32 is internally a u32 but it should never be 0.&quot;);

        // Update the inventory and check the result.
        inventory.update(id.clone(), quantity);
        assert!(inventory.get(&amp;id).unwrap() == quantity);
    }
</code></pre>
<p>In this harness, we use <code>kani::any()</code> to generate the new <code>id</code> and <code>quantity</code>.
<code>kani::any()</code> is a <strong>safe</strong> API function, and it represents only valid values.</p>
<p>If we run this example, Kani verification will succeed, including the assertion that shows that the underlying <code>u32</code> variable  used to represent <code>NonZeroU32</code> cannot be zero, per its type invariant:</p>
<p>You can try it out by running the example under
<a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/arbitrary-variables/"><code>arbitrary-variables</code></a>:</p>
<pre><code>cargo kani --harness safe_update
</code></pre>
<h2 id="unsafe-nondeterministic-variables"><a class="header" href="#unsafe-nondeterministic-variables">Unsafe nondeterministic variables</a></h2>
<p>Kani also includes an <strong>unsafe</strong> method to generate unconstrained nondeterministic variables which do not take type invariants into consideration.
As with any unsafe method in Rust, users have to make sure the right guardrails are put in place to avoid undesirable behavior.</p>
<p>That said, there may be cases where you want to verify your code taking into consideration that some inputs may contain invalid data.</p>
<p>Let's see what happens if we modify our verification harness to use the unsafe method <code>kani::any_raw()</code> to generate the updated value.</p>
<pre><code class="language-rust">    #[kani::proof]
    pub fn unsafe_update() {
        // Create inventory variable.
        let mut inventory = Inventory { inner: VecMap::new() };

        // Create non-deterministic variables for id and quantity with unsafe kani::any_raw().
        let id: ProductId = kani::any();
        let quantity: NonZeroU32 = unsafe { kani::any_raw() };

        // The assert bellow would fail if we comment it out.
        // assert!(id.get() != 0, &quot;NonZeroU32 is internally a u32 but it should never be 0.&quot;);

        // Update the inventory and check the result.
        inventory.update(id.clone(), quantity);
        assert!(inventory.get(&amp;id).unwrap() == quantity); // This unwrap will panic.
    }
</code></pre>
<p>We commented out the assertion that the underlying <code>u32</code> variable cannot be <code>0</code>, since this no longer holds.
The verification will now fail showing that the <code>inventory.get(&amp;id).unwrap()</code> method call can panic.</p>
<p>This is an interesting issue that emerges from how <code>rustc</code> optimizes the memory layout of <code>Option&lt;NonZeroU32&gt;</code>.
The compiler is able to represent <code>Option&lt;NonZeroU32&gt;</code> using <code>32</code> bits by using the value <code>0</code> to represent <code>None</code>.</p>
<p>You can try it out by running the example under <a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/arbitrary-variables/"><code>arbitrary-variables</code></a>:</p>
<pre><code>cargo kani --harness unsafe_update
</code></pre>
<h2 id="safe-nondeterministic-variables-for-custom-types"><a class="header" href="#safe-nondeterministic-variables-for-custom-types">Safe nondeterministic variables for custom types</a></h2>
<p>Now you would like to add a new structure to your library that allow users to represent a review rating, which can go from 0 to 5 stars.
Let's say you add the following implementation:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
pub struct Rating {
    value: u8,
}

impl Rating {
    pub fn from(value: u8) -&gt; Option&lt;Rating&gt; {
        if value &lt;= 5 { Some(Rating { value }) } else { None }
    }

    pub fn get(&amp;self) -&gt; u8 {
        self.value
    }
}

</code></pre>
<p>The easiest way to allow users to create nondeterministic variables of the Rating type which represents values from 0-5 stars is by implementing the <code>kani::Invariant</code> trait.</p>
<p>The implementation only requires you to define a check to your structure that returns whether its current value is valid or not.
In our case, we have the following implementation:</p>
<pre><code class="language-rust">    unsafe impl kani::Invariant for Rating {
        fn is_valid(&amp;self) -&gt; bool {
            self.value &lt;= 5
        }
    }
</code></pre>
<p>Now you can use <code>kani::any()</code> to create valid nondeterministic variables of the Rating type as shown in this harness:</p>
<pre><code class="language-rust">    #[kani::proof]
    pub fn check_rating() {
        let rating = kani::any::&lt;Rating&gt;();
        assert!(rating.get() &lt;= 5);
        assert!(Rating::from(rating.get()).is_some());
    }
</code></pre>
<p>You can try it out by running the example under
<a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/arbitrary-variables/"><code>arbitrary-variables</code></a>:</p>
<pre><code>cargo kani --harness check_rating
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application"><a class="header" href="#application">Application</a></h1>
<p>You may be interested in applying Kani if you're in this situation:</p>
<ol>
<li>You're working on a moderately important project in Rust.</li>
<li>You've already invested heavily in testing to ensure correctness.</li>
<li>You want to invest further, to gain a much higher degree of assurance.</li>
</ol>
<blockquote>
<p>If you haven't already, we recommend techniques like property testing (e.g. with <a href="https://github.com/AltSysrq/proptest"><code>proptest</code></a>) before attempting model checking.
These yield good results, are very cheap to apply, and are often easier to adopt and debug.
Kani is a next step: a tool that can be applied once cheaper tactics are no longer yielding results, or once the easier to detect issues have already been dealt with.</p>
</blockquote>
<p>In this section, we explain <a href="./tool-comparison.html">how Kani compares with other tools</a>
and suggest <a href="./tutorial-real-code.html">where to start applying Kani in real code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-with-other-tools"><a class="header" href="#comparison-with-other-tools">Comparison with other tools</a></h1>
<p><strong>Fuzzing</strong> (for example, with <a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a>) is a unguided approach to random testing.
A fuzzer generally provides an input of random bytes, and then examines fairly generic properties (such as &quot;doesn't crash&quot; or &quot;commit undefined behavior&quot;) about the resulting program.</p>
<p>Fuzzers generally get their power through a kind of evolutionary algorithm that rewards new mutant inputs that &quot;discover&quot; new branches of the program under test.
Fuzzers are excellent for testing security boundaries, precisely because they make no validity assumptions (hence, they are &quot;unguided&quot;) when generating the input.</p>
<p><strong>Property testing</strong> (for example, with <a href="https://github.com/AltSysrq/proptest">Proptest</a>) is a guided approach to random testing.
&quot;Guided&quot; in the sense that the test generally provides a strategy for generating random values that constrains their range.
The purpose of this strategy is to either focus on interesting values, or avoid failing assertions that only hold for a constrained set of inputs.
Tests in this style do actually state properties: <em>For all inputs (of some constrained kind), this condition should hold</em>.</p>
<p>Property testing is often quite effective, but the engine can't fully prove the property: It can only sample randomly a few of those values to test (though property testing libraries frequently give interesting &quot;edge cases&quot; a higher probability, making them more effective at bug-finding).</p>
<p><strong>Model checking</strong> is similar to these techniques in how you use them, but it's non-random and exhaustive (though often only up to some bound on input or problem size).
Thus, properties checked with a model checker are effectively proofs.
Instead of naively trying all possible <em>concrete</em> inputs (which could be infeasible and blow up exponentially), model checkers like Kani will cleverly encode program traces as <em>symbolic</em> &quot;<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a>/<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>&quot; problems, and hand them off to SAT/SMT solvers.
Again, SAT/SMT solving is an <a href="https://en.wikipedia.org/wiki/NP-completeness">NP-complete</a> problem, but most practical programs can be model- checked within milliseconds to seconds (with notable exceptions: you can easily try to reverse a cryptographic hash with a model checker, but good luck getting it to terminate!)</p>
<p>Model checking allows you to prove non-trivial properties about programs, and check those proofs in roughly the same amount of time as a traditional test suite would take to run.
The downside is many types of properties can quickly become &quot;too large&quot; to practically model-check, and so writing &quot;proof harnesses&quot; (very similar to property tests and fuzzer harnesses) requires some skill to understand why the solver is not terminating and fix the structure of the problem you're giving it so that it does.
This process basically boils down to &quot;debugging&quot; the proof.</p>
<h2 id="looking-for-concurrency"><a class="header" href="#looking-for-concurrency">Looking for concurrency?</a></h2>
<p>At present, Kani <a href="./rust-feature-support.html">does not support verifying concurrent code</a>.
Two tools of immediate interest are <a href="https://github.com/tokio-rs/loom">Loom</a> and <a href="https://github.com/awslabs/shuttle">Shuttle</a>.
Loom attempts to check all possible interleavings, while Shuttle chooses interleavings randomly.
The former is sound (like Kani), but the latter is more scalable to large problem spaces (like property testing).</p>
<h2 id="other-tools"><a class="header" href="#other-tools">Other tools</a></h2>
<p>The Rust Formal Methods Interest Group maintains <a href="https://rust-formal-methods.github.io/tools.html">a list of interesting Rust verification tools</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-start-on-real-code"><a class="header" href="#where-to-start-on-real-code">Where to start on real code</a></h1>
<p>It can be daunting to find the right place to start writing proofs for a real-world project.
This section will try to help you get over that hurdle.</p>
<p>In general, you're trying to do three things:</p>
<ol>
<li>Find a place where it'd be valuable to have a proof.</li>
<li>Find a place where it won't be too difficult to prove something, just to start.</li>
<li>Figure out what a feasible longer-term goal might be.</li>
</ol>
<p><strong>By far, the best strategy is to follow your testing.</strong>
Places where proof will be valuable are often places where you've written a lot of tests, because they're valuable there for the same reasons.
Likewise, code structure changes to make functions more unit-testable will also make functions more amenable to proof.
Often, by examining existing unit tests (and especially property tests), you can easily find a relatively self-contained function that's a good place to start.</p>
<h2 id="where-is-proof-valuable"><a class="header" href="#where-is-proof-valuable">Where is proof valuable?</a></h2>
<ol>
<li>
<p>Where complicated things happen with untrusted user input.
These are often the critical &quot;entry points&quot; into the code.
These are also places where you probably want to try other techniques (e.g., fuzz testing).</p>
</li>
<li>
<p>Where <code>unsafe</code> is used extensively.
These are often places where you'll already have concentrated a lot of tests.</p>
</li>
<li>
<p>Where you have a complicated implementation that accomplishes a much simpler abstract problem.
Ideal places for property testing, if you haven't tried that already.
But the usual style of property tests you often write here (generate large random lists of operations, then compare between concrete and abstract model) won't be practical to directly port to model checking.</p>
</li>
<li>
<p>Where normal testing &quot;smells&quot; intractable.</p>
</li>
</ol>
<h2 id="where-is-it-easier-to-start"><a class="header" href="#where-is-it-easier-to-start">Where is it easier to start?</a></h2>
<ol>
<li>
<p>Find crates or files with smaller lists of dependencies.
Dependencies can sometimes blow up the tractability of proofs.
This can usually be handled, but requires a lot more investment to make it happen, and so isn't a good place to start.</p>
</li>
<li>
<p>Don't forget to consider starting with your dependencies.
Sometimes the best place to start won't be your code, but the code that you depend on.
If it's used by more projects that just yours, it will be valuable to more people, too!</p>
</li>
<li>
<p>Find well-tested code.
Code structure changes to make code more unit-testable will make it more provable, too.</p>
</li>
</ol>
<p>Here are some things to avoid, when starting out:</p>
<ol>
<li>
<p>Lots of loops, or at least nested loops.
As we saw in the last section, right now we often need to put upper bounds on these to make more limited claims.</p>
</li>
<li>
<p>Inductive data structures.
These are data structures with unbounded size (e.g., linked lists or trees.)
These can be hard to model since you need to set bounds on their size, similar to what happens with loops.</p>
</li>
<li>
<p>Input/Output code.
Kani doesn't model I/O, so if your code depends on behavior like reading/writing to a file, you won't be able to prove anything.
This is one obvious area where testability helps provability: often we separate I/O and &quot;pure&quot; computation into different functions, so we can unit-test the latter.</p>
</li>
<li>
<p>Deeper call graphs.
Functions that call a lot of other functions can require more investment to make tractable.
They may not be a good starting point.</p>
</li>
<li>
<p>Significant global state.
Rust tends to discourage this, but it still exists in some forms.</p>
</li>
</ol>
<h2 id="your-first-proof"><a class="header" href="#your-first-proof">Your first proof</a></h2>
<p>A first proof will likely start in the following form:</p>
<ol>
<li>Nondeterministically initialize variables that will correspond to function inputs, with as few constraints as possible.</li>
<li>Call the function in question with these inputs.</li>
<li>Don't (yet) assert any post-conditions.</li>
</ol>
<p>Running Kani on this simple starting point will help figure out:</p>
<ol>
<li>What unexpected constraints might be needed on your inputs to avoid &quot;expected&quot; failures.</li>
<li>Whether you're over-constrained. Check the coverage report using <code>--visualize</code>. Ideally you'd see 100% coverage, and if not, it's usually because now you've over-constrained the inputs.</li>
<li>Whether Kani will support all the Rust features involved.</li>
<li>Whether you've started with a tractable problem.
(If the problem is initially intractable, try <code>--default-unwind 1</code> and see if you can follow the techniques in the previous section to put a bound on the problem.)</li>
</ol>
<p>Once you've got something working, the next step is to prove more interesting properties than what Kani covers by default.
You accomplish this by adding new assertions (not just in your harness, but also to the code being run).
Even if a proof harness has no post-conditions being asserted directly, the assertions encountered along the way can be meaningful proof results by themselves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-documentation"><a class="header" href="#developer-documentation">Developer documentation</a></h1>
<p>Kani is an open source project open to external contributions.</p>
<p>The easiest way to contribute is to <a href="https://github.com/model-checking/kani/issues/new/choose">report any
issue</a> you encounter
while using the tool. If you want to contribute to its development,
we recommend looking into <a href="https://github.com/model-checking/kani/contribute">these issues</a>.</p>
<p>In this chapter, we provide documentation that might be helpful for Kani
developers (including external contributors):</p>
<ol>
<li><a href="./workarounds.html">Suggested workarounds</a>.</li>
<li><a href="./cheat-sheets.html">Useful command-line instructions for Kani/CBMC/Git</a>.</li>
<li><a href="./rustc-hacks.html">Development setup recommendations for working with <code>rustc</code></a>.</li>
<li><a href="./testing.html">Guide for testing in Kani</a>.</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: The developer documentation is intended for Kani developers and not
users. At present, the project is under heavy development and some items
discussed in this documentation may stop working without notice (e.g., commands
or configurations). Therefore, we recommend users to not rely on them.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-cbmc"><a class="header" href="#working-with-cbmc">Working with CBMC</a></h1>
<p>This section describes how to access more advanced CBMC options from Kani.</p>
<h2 id="cbmc-arguments"><a class="header" href="#cbmc-arguments">CBMC arguments</a></h2>
<p>Kani is able to handle common CBMC arguments as if they were its own (e.g.,
<code>--default-unwind &lt;n&gt;</code>), but sometimes it may be necessary to use CBMC arguments which
are not handled by Kani.</p>
<p>To pass additional arguments for CBMC, you pass <code>--cbmc-args</code> to Kani. Note that
this &quot;switches modes&quot; from Kani arguments to CBMC arguments: Any arguments that
appear after <code>--cbmc-args</code> are considered to be CBMC arguments, so all Kani
arguments must be placed before it.</p>
<p>Thus, the command line format to invoke <code>cargo kani</code> with CBMC arguments is:</p>
<pre><code class="language-bash">cargo kani [&lt;kani-args&gt;]* --cbmc-args [&lt;cbmc-args&gt;]*
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: In cases where CBMC is not expected to emit a verification output,
you have to use Kani's argument <code>--output-format old</code> to turn off the
post-processing of output from CBMC.</p>
</blockquote>
<h3 id="individual-loop-bounds"><a class="header" href="#individual-loop-bounds">Individual loop bounds</a></h3>
<p>Setting <code>--default-unwind &lt;n&gt;</code> affects every loop in a harness.
Once you know a particular loop is causing trouble, sometimes it can be helpful to provide a specific bound for it.</p>
<p>In the general case, specifying just the highest bound globally for all loops
shouldn't cause any problems, except that the solver may take more time because
<em>all</em> loops will be unwound to the specified bound.</p>
<p>In situations where you need to optimize for the solver, individual bounds for
each loop can be provided on the command line. To do so, we first need to know
the labels assigned to each loop with the CBMC argument <code>--show-loops</code>:</p>
<pre><code># kani src/lib.rs --output-format old --cbmc-args --show-loops
[...]
Loop _RNvCs6JP7pnlEvdt_3lib17initialize_prefix.0:
  file ./src/lib.rs line 11 column 5 function initialize_prefix

Loop _RNvMs8_NtNtCswN0xKFrR8r_4core3ops5rangeINtB5_14RangeInclusivejE8is_emptyCs6JP7pnlEvdt_3lib.0:
  file $RUST/library/core/src/ops/range.rs line 540 column 9 function std::ops::RangeInclusive::&lt;Idx&gt;::is_empty

Loop gen-repeat&lt;[u8; 10]::16806744624734428132&gt;.0:
</code></pre>
<p>This command shows us the labels of the loops involved. Note that, as mentioned
in <a href="cbmc-hacks.html#cbmc-arguments">CBMC arguments</a>, we need to use <code>--output-format old</code> to
avoid post-processing the output from CBMC.</p>
<blockquote>
<p><strong>NOTE</strong>: At the moment, these labels are constructed using the mangled name
of the function and an index. Mangled names are likely to change across
different versions, so this method is highly unstable.</p>
</blockquote>
<p>Then, we can use the CBMC argument <code>--unwindset label_1:bound_1,label_2:bound_2,...</code> to specify an individual bound for each
loop as follows:</p>
<pre><code class="language-bash">kani src/lib.rs --cbmc-args --unwindset _RNvCs6JP7pnlEvdt_3lib17initialize_prefix.0:12
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-rustc"><a class="header" href="#working-with-rustc">Working with <code>rustc</code></a></h1>
<p>Kani is developed on the top of the Rust compiler, which is not distributed on <a href="https://crates.io/">crates.io</a> and depends on
bootstrapping mechanisms to properly build its components.
Thus, our dependency on <code>rustc</code> crates are not declared in our <code>Cargo.toml</code>.</p>
<p>Below are a few hacks that will make it easier to develop on the top of <code>rustc</code>.</p>
<h2 id="code-analysis-for-rustc-definitions"><a class="header" href="#code-analysis-for-rustc-definitions">Code analysis for <code>rustc</code> definitions</a></h2>
<p>IDEs rely on <code>cargo</code> to find dependencies and sources to provide proper code analysis and code completion.
In order to get these features working for <code>rustc</code> crates, you can do the following:</p>
<h3 id="vscode"><a class="header" href="#vscode">VSCode</a></h3>
<p>Add the following to the <code>rust-analyzer</code> extension settings in <code>settings.json</code>:</p>
<pre><code class="language-json">    &quot;rust-analyzer.rustcSource&quot;: &quot;discover&quot;,
    &quot;rust-analyzer.workspace.symbol.search.scope&quot;: &quot;workspace_and_dependencies&quot;,
</code></pre>
<p>Ensure that any packages that use <code>rustc</code> data structures have the following line set in their <code>Cargo.toml</code></p>
<pre><code class="language-toml">[package.metadata.rust-analyzer]
# This package uses rustc crates.
rustc_private=true
</code></pre>
<p>You may also need to install the <code>rustc-dev</code> package using rustup</p>
<pre><code>rustup toolchain install nightly --component rustc-dev
</code></pre>
<h3 id="clion--intellij"><a class="header" href="#clion--intellij">CLion / IntelliJ</a></h3>
<p>This is not a great solution, but it works for now (see <a href="https://github.com/intellij-rust/intellij-rust/issues/1618">https://github.com/intellij-rust/intellij-rust/issues/1618</a>
for more details).
Edit the <code>Cargo.toml</code> of the package that you're working on and add artificial dependencies on the <code>rustc</code> packages that you would like to explore.</p>
<pre><code class="language-toml"># This configuration doesn't exist so it shouldn't affect your build.
[target.'cfg(KANI_DEV)'.dependencies]
# Adjust the path here to point to a local copy of the rust compiler.
# The best way is to use the rustup path. Replace &lt;toolchain&gt; with the
# proper name to your toolchain.
rustc_driver = { path = &quot;~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/rustc-src/rust/compiler/rustc_driver&quot; }
rustc_interface = { path = &quot;~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/rustc-src/rust/compiler/rustc_interface&quot; }
</code></pre>
<p><strong>Don't forget to rollback the changes before you create your PR.</strong></p>
<h2 id="custom-rustc"><a class="header" href="#custom-rustc">Custom <code>rustc</code></a></h2>
<p>There are a few reasons why you may want to use your own copy of <code>rustc</code>. E.g.:</p>
<ul>
<li>Enable more verbose logs.</li>
<li>Use a debug build to allow you to step through <code>rustc</code> code.</li>
<li>Test changes to <code>rustc</code>.</li>
</ul>
<p>We will assume that you already have a Kani setup and that the variable <code>KANI_WORKSPACE</code> contains the path to your Kani workspace.</p>
<p><strong>It's highly recommended that you start from the commit that corresponds to the current <code>rustc</code> version from your workspace.</strong>
To get that information, run the following command:</p>
<pre><code class="language-bash">cd ${KANI_WORKSPACE} # Go to your Kani workspace.
rustc --version # This will print the commit id. Something like:
# rustc 1.60.0-nightly (0c292c966 2022-02-08)
#                       ^^^^^^^^^ this is used as the ${COMMIT_ID} below
# E.g.:
COMMIT_ID=0c292c966
</code></pre>
<p>First you need to clone and build stage 2 of the compiler.
You should tweak the configuration to satisfy your use case.
For more details, see <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html">https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html</a> and <a href="https://rustc-dev-guide.rust-lang.org/building/suggested.html">https://rustc-dev-guide.rust-lang.org/building/suggested.html</a>.</p>
<pre><code class="language-bash">git clone https://github.com/rust-lang/rust.git
cd rust
git checkout ${COMMIT_ID:?&quot;Missing rustc commit id&quot;}
./configure --enable-extended --tools=src,rustfmt,cargo --enable-debug --set=llvm.download-ci-llvm=true
./x.py build -i --stage 2
</code></pre>
<p>Now create a custom toolchain (here we name it <code>custom-toolchain</code>):</p>
<pre><code class="language-bash"># Use x86_64-apple-darwin for MacOs
rustup toolchain link custom-toolchain build/x86_64-unknown-linux-gnu/stage2
cp build/x86_64-unknown-linux-gnu/stage2-tools-bin/* build/x86_64-unknown-linux-gnu/stage2/bin/
</code></pre>
<p>Finally, override the current toolchain in your kani workspace and rebuild kani:</p>
<pre><code class="language-bash">cd ${KANI_WORKSPACE}
rustup override set custom-toolchain
cargo clean
cargo build
</code></pre>
<h1 id="enable-rustc-logs"><a class="header" href="#enable-rustc-logs">Enable <code>rustc</code> logs</a></h1>
<p>In order to enable logs, you can just define the <code>RUSTC_LOG</code> variable, as documented here: <a href="https://rustc-dev-guide.rust-lang.org/tracing.html">https://rustc-dev-guide.rust-lang.org/tracing.html</a>.</p>
<p>Note that depending on the level of logs you would like to enable, you'll need to build your own version of <code>rustc</code> as described above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-cheat-sheets"><a class="header" href="#command-cheat-sheets">Command cheat sheets</a></h1>
<p>Development work in the Kani project depends on multiple tools. Regardless of
your familiriaty with the project, the commands below may be useful for
development purposes.</p>
<h2 id="kani"><a class="header" href="#kani">Kani</a></h2>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<pre><code class="language-bash"># Build all packages in the repository
cargo build --workspace
</code></pre>
<pre><code class="language-bash"># Error &quot;'rustc' panicked at 'failed to lookup `SourceFile` in new context'&quot;
# or similar error?
# Clean `kani-compiler` and re-build:
cargo clean -p kani-compiler
cargo build -p kani-compiler
</code></pre>
<h3 id="test"><a class="header" href="#test">Test</a></h3>
<pre><code class="language-bash"># Full regression suite (does not run bookrunner)
./scripts/kani-regression.sh
</code></pre>
<pre><code class="language-bash"># Delete regression test caches (Linux)
rm -r build/x86_64-unknown-linux-gnu/tests/
</code></pre>
<pre><code class="language-bash"># Delete regression test caches (macOS)
rm -r build/x86_64-apple-darwin/tests/
</code></pre>
<pre><code class="language-bash"># Test suite run (we can only run one at a time)
# cargo run -p compiletest -- --suite ${suite} --mode ${mode}
cargo run -p compiletest -- --suite kani --mode kani
</code></pre>
<pre><code class="language-bash"># Run bookrunner
./scripts/setup/install_bookrunner_deps.sh
cargo run -p bookrunner
</code></pre>
<pre><code class="language-bash"># Build documentation
cd docs
./build-docs.sh
</code></pre>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>These can help understand what Kani is generating or encountering on an example or test file:</p>
<pre><code class="language-bash"># Enable `debug!` macro logging output when running Kani:
kani --debug file.rs
</code></pre>
<pre><code class="language-bash"># Keep CBMC Symbol Table and Goto-C output (.json and .goto)
kani --keep-temps file.rs
</code></pre>
<pre><code class="language-bash"># Generate &quot;C code&quot; from CBMC IR (.c)
kani --gen-c file.rs
</code></pre>
<h2 id="cbmc"><a class="header" href="#cbmc">CBMC</a></h2>
<pre><code class="language-bash"># See CBMC IR from a C file:
goto-cc file.c -o file.out
goto-instrument --print-internal-representation file.out
# or (for json symbol table)
cbmc --show-symbol-table --json-ui file.out
# or (an alternative concise format)
cbmc --show-goto-functions file.out
</code></pre>
<pre><code class="language-bash"># Recover C from goto-c binary
goto-instrument --dump-c file.out &gt; file.gen.c
</code></pre>
<h2 id="git"><a class="header" href="#git">Git</a></h2>
<p>The Kani project follows the <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits">squash and merge option</a> for pull request merges.
As a result:</p>
<ol>
<li>The title of your pull request will become the main commit message.</li>
<li>The messages from commits in your pull request will appear by default as a bulleted list in the main commit message body.</li>
</ol>
<p>But the main commit message body is editable at merge time, so you don't have to worry about &quot;typo fix&quot; messages because these can be removed before merging.</p>
<pre><code class="language-bash"># Set up your git fork
git remote add fork git@github.com:${USER}/kani.git
</code></pre>
<pre><code class="language-bash"># Reset everything. Don't have any uncommitted changes!
git clean -xffd
git submodule foreach --recursive git clean -xffd
git submodule update --init
</code></pre>
<pre><code class="language-bash"># Done with that PR, time for a new one?
git switch main
git pull origin
git submodule update --init
cd src/kani-compiler
cargo build --workspace
</code></pre>
<pre><code class="language-bash"># Need to update local branch (e.g. for an open pull request?)
git fetch origin
git merge origin/main
# Or rebase, but that requires a force push,
# and because we squash and merge, an extra merge commit in a PR doesn't hurt.
</code></pre>
<pre><code class="language-bash"># Checkout a pull request locally without the github cli
git fetch origin pull/$ID/head:pr/$ID
git switch pr/$ID
</code></pre>
<pre><code class="language-bash"># Search only git-tracked files
git grep codegen_panic
</code></pre>
<pre><code class="language-bash"># See all commits that are part of Kani, not part of Rust
git log --graph --oneline origin/upstream-rustc..origin/main
</code></pre>
<pre><code class="language-bash"># See all files modified by Kani (compared to upstream Rust)
git diff --stat origin/upstream-rustc..origin/main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Testing in Kani is carried out in multiple ways. There are at least
two very good reasons to do it:</p>
<ol>
<li>
<p><strong>Software regression</strong>: A regression is a type of bug
that appears after a change is introduced where a feature that
was previously working has unexpectedly stopped working.</p>
<p>Regression testing allows one to prevent a software regression
from happening by running a comprehensive set of working tests
before any change is committed to the project.</p>
</li>
<li>
<p><strong>Software metrics</strong>: A metric is a measure of software
characteristics which are quantitative and countable. Metrics are
particularly valuable for project management purposes.</p>
</li>
</ol>
<p>We recommend reading our section on <a href="./regression-testing.html">Regression Testing</a>
if you're interested in Kani development. At present, we obtain metrics based
on the <a href="./bookrunner.html">book runner</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regression-testing"><a class="header" href="#regression-testing">Regression testing</a></h1>
<p>Kani relies on a quite extensive range of tests to perform regression testing.
Regression testing can be executed by running the command:</p>
<pre><code class="language-bash">./scripts/kani-regression.sh
</code></pre>
<p>The <code>kani-regression.sh</code> script executes different testing commands, which we classify into:</p>
<ul>
<li><a href="regression-testing.html#kani-testing-suites">Kani testing suites</a></li>
<li><a href="regression-testing.html#rust-unit-tests">Rust unit tests</a></li>
<li><a href="regression-testing.html#python-unit-tests">Python unit tests</a></li>
<li><a href="regression-testing.html#script-based-tests">Script-based tests</a></li>
</ul>
<p>See below for a description of each one.</p>
<p>Note that regression testing is run whenever a Pull Request is opened, updated or merged
into the main branch. Therefore, it's a good idea to run regression testing locally before
submitting a Pull Request for Kani.</p>
<h2 id="kani-testing-suites"><a class="header" href="#kani-testing-suites">Kani testing suites</a></h2>
<p>The Kani testing suites are the main testing resource for Kani. In most cases, the
tests contained in the Kani testing suites are single Rust files that are run
using the following command:</p>
<pre><code class="language-bash">kani file.rs &lt;options&gt;
</code></pre>
<p>Command-line options can be passed to the test by adding a special
comment to the file. See <a href="regression-testing.html#testing-options">testing options</a> for more details.</p>
<p>In particular, the Kani testing suites are composed of:</p>
<ul>
<li><code>kani</code>: The main testing suite for Kani. The test is a single Rust file that's
run through Kani. In general, the test passes if verification with Kani
is successful, otherwise it fails.</li>
<li><code>firecracker</code>: Works like <code>kani</code> but contains tests inspired by
<a href="https://github.com/firecracker-microvm/firecracker">Firecracker</a> code.</li>
<li><code>prusti</code>: Works like <code>kani</code> but contains tests from the
<a href="https://github.com/viperproject/prusti-dev">Prusti</a> tool.</li>
<li><code>smack</code>: Works like <code>kani</code> but contains tests from the
<a href="https://github.com/smackers/smack">SMACK</a> tool.</li>
<li><code>kani-fixme</code>: Similar to <code>kani</code>, but runs ignored tests from the <code>kani</code> testing
suite (i.e., tests with <code>fixme</code> or <code>ignore</code> in their name).
Allows us to detect when a previously not supported test becomes
supported. More details in <a href="regression-testing.html#fixme-tests">&quot;Fixme&quot; tests</a>.</li>
<li><code>expected</code>: Similar to <code>kani</code> but with an additional check which ensures that
lines appearing in <code>*.expected</code> files appear in the output
generated by <code>kani</code>.</li>
<li><code>ui</code>: Works like <code>expected</code>, but focuses on the user interface (e.g.,
warnings) instead of the verification output.</li>
<li><code>cargo-kani</code>: This suite is designed to test the <code>cargo-kani</code> command. As such,
this suite works with packages instead of single Rust files.
Arguments can be specified in the <code>Cargo.toml</code> configuration file.
Similar to the <code>expected</code> suite, we look for <code>*.expected</code> files
for each harness in the package.</li>
</ul>
<p>We've extended
<a href="https://rustc-dev-guide.rust-lang.org/tests/intro.html"><code>compiletest</code></a> (the
Rust compiler testing framework) to work with these suites. That way, we take
advantage of all <code>compiletest</code> features (e.g., parallel execution).</p>
<h3 id="testing-stages"><a class="header" href="#testing-stages">Testing stages</a></h3>
<p>The process of running single-file tests is split into three stages:</p>
<ul>
<li><code>check</code>: This stage uses the Rust front-end to detect if the example is valid
Rust code.</li>
<li><code>codegen</code>: This stage uses the Kani back-end to determine if we can generate
GotoC code.</li>
<li><code>verify</code>: This stage uses CBMC to obtain a verification result.</li>
</ul>
<p>If a test fails, the error message will include the stage where it failed:</p>
<pre><code>error: test failed: expected check success, got failure
</code></pre>
<p>When working on a test that's expected to fail, there are two options to
indicate an expected failure. The first one is to add a comment</p>
<pre><code class="language-rust">// kani-&lt;stage&gt;-fail
</code></pre>
<p>at the top of the test file, where <code>&lt;stage&gt;</code> is the stage where the test is
expected to fail.</p>
<p>The other option is to use the predicate <code>kani::expect_fail(cond, message)</code>
included in the Kani library. The <code>cond</code> in <code>kani::expect_fail</code> is a condition
that you expect not to hold during verification. The testing framework expects
one <code>EXPECTED FAIL</code> message in the verification output for each use of the
predicate.</p>
<blockquote>
<p><strong>NOTE</strong>: <code>kani::expect_fail</code> is only useful to indicate failure in the
<code>verify</code> stage, errors in other stages will be considered testing failures.</p>
</blockquote>
<h3 id="testing-options"><a class="header" href="#testing-options">Testing options</a></h3>
<p>Many tests will require passing command-line options to Kani. These options can
be specified in single Rust files by adding a comment at the top of the file:</p>
<pre><code class="language-rust">// kani-flags: &lt;options&gt;
</code></pre>
<p>For example, to use an unwinding value of 4 in a test, we can write:</p>
<pre><code class="language-rust">// kani-flags: --default-unwind 4
</code></pre>
<p>For <code>cargo-kani</code> tests, the preferred way to pass command-line options is adding
them to <code>Cargo.toml</code>. See <a href="./cargo-kani.html"><code>Usage - On a package</code></a> for more details.</p>
<h3 id="fixme-tests"><a class="header" href="#fixme-tests">&quot;Fixme&quot; tests</a></h3>
<p>Any test containing <code>fixme</code> or <code>ignore</code> in its name is considered a test not
supported for some reason (i.e., they return an unexpected verification result).</p>
<p>However, &quot;fixme&quot; tests included in the <code>kani</code> folder are run via the <code>kani-fixme</code>
testing suite. <code>kani-fixme</code> works on test files from <code>kani</code> but:</p>
<ol>
<li>Only runs tests whose name contains <code>fixme</code> or <code>ignore</code> (ignoring the rest).</li>
<li>The expected outcome is failure. In other words, a test is successful if it
fails.</li>
</ol>
<p>We welcome contributions with &quot;fixme&quot; tests which demonstrate a bug or
unsupported feature in Kani. Ideally, the test should include some comments
regarding:</p>
<ul>
<li>The expected result of the test.</li>
<li>The actual result of the test (e.g., interesting parts of the output).</li>
<li>Links to related issues.</li>
</ul>
<p>To include a new &quot;fixme&quot; test in <code>kani</code> you only need to ensure its name contains
<code>fixme</code> or <code>ignore</code>. If your changes to Kani cause a &quot;fixme&quot; test to become
supported, you only need to rename it so the name does not contain <code>fixme</code> nor
<code>ignore</code>.</p>
<h2 id="rust-unit-tests"><a class="header" href="#rust-unit-tests">Rust unit tests</a></h2>
<p>These tests follow the
<a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">Rust unit testing</a>
style.</p>
<p>At present, Kani runs unit tests from the following packages:</p>
<ul>
<li><code>cprover_bindings</code></li>
<li><code>kani-compiler</code></li>
<li><code>cargo-kani</code></li>
</ul>
<h2 id="python-unit-tests"><a class="header" href="#python-unit-tests">Python unit tests</a></h2>
<p>We use the Python <a href="https://docs.python.org/3/library/unittest.html">unit testing framework</a> to
test the CBMC JSON parser.</p>
<h2 id="script-based-tests"><a class="header" href="#script-based-tests">Script-based tests</a></h2>
<p>These are tests which are run using scripts. Scripting gives us the ability to
perform ad-hoc checks that cannot be done otherwise. They are currently used
for:</p>
<ul>
<li>Standard library codegen</li>
<li>Firecracker virtio codegen</li>
<li>Diamond dependency</li>
</ul>
<p>In fact, most of them are equivalent to running <code>cargo kani</code> and performing
checks on the output. The downside to scripting is that these tests will always
be run, even if there have not been any changes since the last time the
regression was run.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="book-runner"><a class="header" href="#book-runner">Book runner</a></h1>
<p>The <a href="./bookrunner/index.html">book runner</a> is a testing tool based on <a href="https://github.com/awslabs/aws-build-accumulator">Litani</a>.</p>
<p>The purpose of the book runner is to get data about feature coverage in Kani.
To this end, we use Rust code snippet examples from the following general Rust documentation books:</p>
<ul>
<li>The Rust Reference</li>
<li>The Rustonomicon</li>
<li>The Rust Unstable Book</li>
<li>Rust By Example</li>
</ul>
<p>However, not all examples from these books are suited for verification.
For instance, some of them are only included to show what is valid Rust code (or what is not).</p>
<p>Because of that, we run up to three different types of jobs when generating the report:</p>
<ul>
<li><code>check</code> jobs: This check uses the Rust front-end to detect if the example is valid Rust code.</li>
<li><code>codegen</code> jobs: This check uses the Kani back-end to determine if we can generate GotoC code.</li>
<li><code>verification</code> jobs: This check uses CBMC to obtain a verification result.</li>
</ul>
<p>Note that these are incremental: A <code>verification</code> job depends on a previous <code>codegen</code> job.
Similary, a <code>codegen</code> job depends on a <code>check</code> job.</p>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://github.com/awslabs/aws-build-accumulator">Litani</a> does not
support hierarchical views at the moment. For this reason, we are publishing a
<a href="./bookrunner/bookrunner.txt">text version of the book runner report</a> which
displays the same results in a hierarchical way while we work on <a href="https://github.com/model-checking/kani/issues/699">improvements
for the visualization and navigation of book runner
results</a>.</p>
</blockquote>
<p>Before running the above mentioned jobs, we pre-process the examples to:</p>
<ol>
<li>Set the expected output according to flags present in the code snippet.</li>
<li>Add any required compiler/Kani flags (e.g., unwinding).</li>
</ol>
<p>Finally, we run all jobs, collect their outputs and compare them against the expected outputs.
The results are summarized as follows: If the obtained and expected outputs differ,
the color of the stage bar will be red. Otherwise, it will be blue.
If an example shows one red bar, it's considered a failed example that cannot be handled by Kani.</p>
<p>The <a href="./bookrunner/index.html">book runner report</a> and <a href="./bookrunner/bookrunner.txt">its text version</a> are
automatically updated whenever a PR gets merged into Kani.</p>
<h2 id="the-book-running-procedure"><a class="header" href="#the-book-running-procedure">The book running procedure</a></h2>
<p>This section describes how the book runner operates at a high level.</p>
<p>To kick off the book runner process use:</p>
<pre><code class="language-bash">cargo run -p bookrunner
</code></pre>
<p>The main function of the bookrunner is <code>generate_run()</code> (code available
<a href="https://github.com/model-checking/kani/blob/main/tools/bookrunner/src/books.rs">here</a>)
which follows these steps:</p>
<ol>
<li>Sets up all the books, including data about their summaries.</li>
<li>Then, for each book:</li>
</ol>
<ul>
<li>Calls the <code>parse_hierarchy()</code> method to parse its summary
files.</li>
<li>Calls the <code>extract_examples()</code> method to extract all
examples from the book. Note that <code>extract_examples()</code> uses <code>rustdoc</code>
functions to ensure the extracted examples are runnable.</li>
<li>Checks if there is a corresponding <code>.props</code> file
in <code>src/tools/bookrunner/configs/</code>. If there is, prepends the contents of these files
(<a href="./regression-testing.html#testing-options">testing options</a>) to the example.</li>
<li>The resulting examples are written to the <code>src/test/bookrunner/books/</code> folder.</li>
</ul>
<blockquote>
<p>In general, the path to a given example is
<code>src/test/bookrunner/books/&lt;book&gt;/&lt;chapter&gt;/&lt;section&gt;/&lt;subsection&gt;/&lt;line&gt;.rs</code>
where <code>&lt;line&gt;</code> is the line number where the example appears in the markdown
file where it's written. The <code>.props</code> files mentioned above follow the same
naming scheme in order to match them and detect conflicts.</p>
</blockquote>
<ol start="3">
<li>Runs all examples using
<a href="https://github.com/awslabs/aws-build-accumulator">Litani</a> with the
<code>litani_run_tests()</code> function.</li>
<li>Parses the Litani log file with <code>parse_litani_output(...)</code>.</li>
<li>Generates the <a href="./bookrunner/bookrunner.txt">text version of the bookrunner</a>
with <code>generate_text_bookrunner(...)</code>.</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: Any changes done to the examples in <code>src/test/bookrunner/books/</code> may
be overwritten if the bookrunner is executed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<p>Like other tools, Kani comes with some limitations. In some cases, these
limitations are inherent because of the techniques it's based on. In other
cases, it's just a matter of time and effort to remove these limitations (e.g.,
specific unsupported Rust language features).</p>
<p>In this chapter, we do the following to document these limitations:</p>
<ul>
<li>Discuss the effect of <a href="./undefined-behaviour.html">Rust undefined behaviour</a>.</li>
<li>Summarize the <a href="./rust-feature-support.html">current support for Rust features</a>.</li>
<li>Explain the need for <a href="./overrides.html">overrides</a> and list all overriden
symbols.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="undefined-behaviour"><a class="header" href="#undefined-behaviour">Undefined Behaviour</a></h1>
<h2 id="the-effect-of-undefined-behaviour-on-program-verification"><a class="header" href="#the-effect-of-undefined-behaviour-on-program-verification">The Effect of Undefined Behaviour on Program Verification</a></h2>
<p>Rust has a broad definition of <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behaviour</a> (UB).
The <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust documentation warns</a> that UB can have unexpected, non-local effects:</p>
<blockquote>
<p><strong>Note</strong>: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</p>
</blockquote>
<p>If a program has UB, the semantics of the rest of the program are <strong>undefined</strong>.
As a result, if the program under verification contains UB then, in principle, the program (including its representation in MIR analyzed by Kani) <strong>has no semantics</strong> and hence could do anything, including violating the guarantees checked by Kani. 
This means that verification results are subject to the proviso that the program under verification does not contain UB.</p>
<h2 id="what-forms-of-undefined-behaviour-can-rust-exhibit"><a class="header" href="#what-forms-of-undefined-behaviour-can-rust-exhibit">What forms of Undefined Behaviour can Rust Exhibit</a></h2>
<p>Rust’s <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">definition of UB</a> is so broad that Rust has the following warning:</p>
<blockquote>
<p><strong>Warning</strong>
The following list is not exhaustive. There is no formal model of Rust's semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the Rustonomicon (https://doc.rust-lang.org/nomicon/index.html) before writing unsafe code.</p>
</blockquote>
<p>Given the lack of a formal semantics for UB, and given Kani's focus on memory safety, there are classes of UB which Kani does not detect.
A non-exhaustive list of these, based on the the non-exhaustive list from the <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust documentation</a>, is:</p>
<ul>
<li>Data races. 
<ul>
<li>Kani focuses on sequential code.</li>
</ul>
</li>
<li>Breaking the pointer aliasing rules (http://llvm.org/docs/LangRef.html#pointer-aliasing-rules). 
<ul>
<li>Kani can detect if misuse of pointers causes memory safety or assertion violations, but does not not track reference lifetimes.</li>
</ul>
</li>
<li>Mutating immutable data.
<ul>
<li>Kani can detect if modification of immutable data causes memory safety or assertion violations, but does not not track reference lifetimes.</li>
</ul>
</li>
<li>Invoking undefined behavior via compiler intrinsics.
<ul>
<li>Kani makes a best effort attempt to check the preconditions of compiler intrinsics, but does not guarantee to do so in all cases.</li>
</ul>
</li>
<li>Executing code compiled with platform features that the current platform does not support (see <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-target_feature-attribute">target_feature</a>).
<ul>
<li>Kani relies on <code>rustc</code> to check for this case.</li>
</ul>
</li>
<li>Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.
<ul>
<li>Kani relies on <code>rustc</code> to check for this case.</li>
</ul>
</li>
<li>Producing an invalid value, even in private fields and locals. 
<ul>
<li>Kani provides a <a href="./tutorial-nondeterministic-variables.html#safe-nondeterministic-variables-for-custom-types">mechanism</a> <code>is_valid()</code> which users can use to check validity of objects, but it does not currently apply to all types.</li>
</ul>
</li>
<li>Incorrect use of inline assembly.
<ul>
<li>Kani does not support inline assembly.</li>
</ul>
</li>
</ul>
<p>Kani makes a best-effort attempt to detect some cases of UB:</p>
<ul>
<li>Evaluating a dereference expression (<code>*expr</code>) on a raw pointer that is dangling or unaligned.
<ul>
<li>Kani can detect invalid dereferences, but may not detect them in <a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">place expression context</a>.</li>
</ul>
</li>
<li>Invoking undefined behavior via compiler intrinsics.
<ul>
<li>See <a href="./rust-feature-support/intrinsics.html">current support for compiler intrinsics</a>.</li>
</ul>
</li>
<li>Producing an invalid value, even in private fields and locals. 
<ul>
<li>Kani provides a <a href="./tutorial-nondeterministic-variables.html#safe-nondeterministic-variables-for-custom-types">mechanism</a> <code>is_valid()</code> which users can use to check validity of objects, but it does not currently apply to all types.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-feature-support"><a class="header" href="#rust-feature-support">Rust feature support</a></h1>
<p>The table below tries to summarize the current support in Kani for
the Rust language features according to the <a href="https://doc.rust-lang.org/stable/reference/">Rust Reference</a>.
We use the following values to indicate the level of support:</p>
<ul>
<li><strong>Yes</strong>: The feature is fully supported. We are not aware of any issue with it.</li>
<li><strong>Partial</strong>: The feature is at least partially supported. We are aware of some issue with
with it.</li>
<li><strong>No</strong>: The feature is not supported. Some support may be available but analyses should not be trusted.</li>
</ul>
<p>As with all software, bugs may be found anywhere regardless of the level of support. In such cases, we
would greatly appreciate that you <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md">filed a bug report</a>.</p>
<table><thead><tr><th>Reference</th><th>Feature</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>3.1</td><td>Macros By Example</td><td>Yes</td><td></td></tr>
<tr><td>3.2</td><td>Procedural Macros</td><td>Yes</td><td></td></tr>
<tr><td>4</td><td>Crates and source files</td><td>Yes</td><td></td></tr>
<tr><td>5</td><td>Conditional compilation</td><td>Yes</td><td></td></tr>
<tr><td>6.1</td><td>Modules</td><td>Yes</td><td></td></tr>
<tr><td>6.2</td><td>Extern crates</td><td>Yes</td><td></td></tr>
<tr><td>6.3</td><td>Use declarations</td><td>Yes</td><td></td></tr>
<tr><td>6.4</td><td>Functions</td><td>Yes</td><td></td></tr>
<tr><td>6.5</td><td>Type aliases</td><td>Yes</td><td></td></tr>
<tr><td>6.6</td><td>Structs</td><td>Yes</td><td></td></tr>
<tr><td>6.7</td><td>Enumerations</td><td>Yes</td><td></td></tr>
<tr><td>6.8</td><td>Unions</td><td>Yes</td><td></td></tr>
<tr><td>6.9</td><td>Constant items</td><td>Yes</td><td></td></tr>
<tr><td>6.10</td><td>Static items</td><td>Yes</td><td></td></tr>
<tr><td>6.11</td><td>Traits</td><td>Yes</td><td></td></tr>
<tr><td>6.12</td><td>Implementations</td><td>Yes</td><td></td></tr>
<tr><td>6.13</td><td>External blocks</td><td>Yes</td><td></td></tr>
<tr><td>6.14</td><td>Generic parameters</td><td>Yes</td><td></td></tr>
<tr><td>6.15</td><td>Associated Items</td><td>Yes</td><td></td></tr>
<tr><td>7</td><td>Attributes</td><td>Yes</td><td></td></tr>
<tr><td>8.1</td><td>Statements</td><td>Yes</td><td></td></tr>
<tr><td>8.2.1</td><td>Literal expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.2</td><td>Path expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.3</td><td>Block expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.4</td><td>Operator expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.5</td><td>Grouped expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.6</td><td>Array and index expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.7</td><td>Tuple and index expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.8</td><td>Struct expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.9</td><td>Call expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.10</td><td>Method call expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.11</td><td>Field access expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.12</td><td>Closure expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.13</td><td>Loop expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.14</td><td>Range expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.15</td><td>If and if let expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.16</td><td>Match expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.17</td><td>Return expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.18</td><td>Await expressions</td><td>No</td><td>See <a href="rust-feature-support.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>9</td><td>Patterns</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/707">#707</a></td></tr>
<tr><td>10.1.1</td><td>Boolean type</td><td>Yes</td><td></td></tr>
<tr><td>10.1.2</td><td>Numeric types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.3</td><td>Textual types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.4</td><td>Never type</td><td>Yes</td><td></td></tr>
<tr><td>10.1.5</td><td>Tuple types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.6</td><td>Array types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.7</td><td>Slice types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.8</td><td>Struct types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.9</td><td>Enumerated types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.10</td><td>Union types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.11</td><td>Function item types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.12</td><td>Closure types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.13</td><td>Pointer types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.14</td><td>Function pointer types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.15</td><td>Trait object types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.16</td><td>Impl trait type</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.17</td><td>Type parameters</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.18</td><td>Inferred type</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.2</td><td>Dynamically Sized Types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.3</td><td>Type layout</td><td>Yes</td><td></td></tr>
<tr><td>10.4</td><td>Interior mutability</td><td>Yes</td><td></td></tr>
<tr><td>10.5</td><td>Subtyping and Variance</td><td>Yes</td><td></td></tr>
<tr><td>10.6</td><td>Trait and lifetime bounds</td><td>Yes</td><td></td></tr>
<tr><td>10.7</td><td>Type coercions</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.8</td><td>Destructors</td><td>Partial</td><td></td></tr>
<tr><td>10.9</td><td>Lifetime elision</td><td>Yes</td><td></td></tr>
<tr><td>11</td><td>Special types and traits</td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Box&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Rc&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Arc&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Pin&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>UnsafeCell&lt;T&gt;</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>PhantomData&lt;T&gt;</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td>Operator Traits</td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Deref</code> and <code>DerefMut</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Drop</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Copy</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Clone</code></td><td>Yes</td><td></td></tr>
<tr><td>14</td><td>Linkage</td><td>Yes</td><td></td></tr>
<tr><td>15.1</td><td>Unsafe functions</td><td>Yes</td><td></td></tr>
<tr><td>15.2</td><td>Unsafe blocks</td><td>Yes</td><td></td></tr>
<tr><td>15.3</td><td>Behavior considered undefined</td><td>Partial</td><td></td></tr>
<tr><td></td><td>Data races</td><td>No</td><td>See <a href="rust-feature-support.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td></td><td>Dereferencing dangling raw pointers</td><td>Yes</td><td></td></tr>
<tr><td></td><td>Dereferencing unaligned raw pointers</td><td>No</td><td></td></tr>
<tr><td></td><td>Breaking pointer aliasing rules</td><td>No</td><td></td></tr>
<tr><td></td><td>Mutating immutable data</td><td>No</td><td></td></tr>
<tr><td></td><td>Invoking undefined behavior via compiler intrinsics</td><td>Partial</td><td>See <a href="rust-feature-support.html#intrinsics">Notes - Intrinsics</a></td></tr>
<tr><td></td><td>Executing code compiled with platform features that the current platform does not support</td><td>No</td><td></td></tr>
<tr><td></td><td>Producing an invalid value, even in private fields and locals</td><td>No</td><td></td></tr>
</tbody></table>
<h2 id="notes-on-partially-or-unsupported-features"><a class="header" href="#notes-on-partially-or-unsupported-features">Notes on partially or unsupported features</a></h2>
<h3 id="code-generation-for-unsupported-features"><a class="header" href="#code-generation-for-unsupported-features">Code generation for unsupported features</a></h3>
<p>Kani aims to be an industrial verification tool. Most industrial crates may
include unsupported features in parts of their code that do not need to be
verified. In general, this should not prevent users using Kani to verify their code.</p>
<p>Because of that, the general rule is that Kani generates an <code>assert(false)</code>
statement followed by an <code>assume(false)</code> statement when compiling any
unsupported feature. <code>assert(false)</code> will cause verification to fail if the
statement is reachable during the verification stage, while <code>assume(false)</code> will
block any further exploration of the path. However, the analysis will not be
affected if the statement is not reachable from the code under verification, so
users can still verify components of their code that do not use unsupported
features.</p>
<p>In a few cases, Kani aborts execution if the analysis could be affected in
some way because of an unsupported feature (e.g., global ASM).</p>
<h3 id="assembly"><a class="header" href="#assembly">Assembly</a></h3>
<p>Kani does not support assembly code for now. We may add it in the future but at
present there are no plans to do so.</p>
<p>Check out the tracking issues for <a href="https://github.com/model-checking/kani/issues/2">inline assembly (<code>asm!</code>
macro)</a> and <a href="https://github.com/model-checking/kani/issues/316">global assembly
(<code>asm_global!</code> macro)</a> to know
more about the current status.</p>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>Concurrent features are currently out of scope for Kani. In general, the
verification of concurrent programs continues to be an open research problem
where most tools that analyze concurrent code lack support for other features.
Because of this, Kani emits a warning whenever it encounters concurrent code and
compiles as if it was sequential code.</p>
<h3 id="standard-library-functions"><a class="header" href="#standard-library-functions">Standard library functions</a></h3>
<p>At present, Kani is able to link in functions from the standard library but the
generated code will not contain them unless they are generic, intrinsics,
inlined or macros. Missing functions are treated in a similar way to <a href="rust-feature-support.html#code-generation-for-unsupported-features">unsupported
features</a>.
This results in verification failures if a call to one of these missing functions
is reachable.</p>
<p>We've done some experiments to embed the standard library into the generated
code, but this causes verification times to increase significantly. As of now,
we've not been able to find a simple solution for <a href="https://github.com/model-checking/kani/issues/581">this
issue</a>, but we have some
ideas for future work in this direction. At present, Kani
<a href="./overrides.html">overrides</a> a few common functions (e.g., print macros) as
a workaround.</p>
<h3 id="advanced-features"><a class="header" href="#advanced-features">Advanced features</a></h3>
<p>The semantics around some advanced features (traits, types, etc.) from Rust are
not formally defined which makes it harder to ensure that we can properly model
all their use cases.</p>
<p>In particular, there are some outstanding issues to note here:</p>
<ul>
<li>Unimplemented <code>PointerCast::ClosureFnPointer</code> in
<a href="https://github.com/model-checking/kani/issues/274">#274</a> and <code>Variant</code> case
in projections type in
<a href="https://github.com/model-checking/kani/issues/448">#448</a>.</li>
<li>Unexpected fat pointer results in
<a href="https://github.com/model-checking/kani/issues/277">#277</a>,
<a href="https://github.com/model-checking/kani/issues/327">#327</a> and
<a href="https://github.com/model-checking/kani/issues/676">#676</a>.</li>
</ul>
<p>We are particularly interested in bug reports concerning
these features, so please <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md">file a bug
report</a>
if you're aware of one.</p>
<h3 id="panic-strategies"><a class="header" href="#panic-strategies">Panic strategies</a></h3>
<p>Rust has two different strategies when a panic occurs:</p>
<ol>
<li>Stack unwinding (default): Walks back the stack cleaning up the data from
each function it encounters.</li>
<li>Abortion: Immediately ends the program without cleaning up.</li>
</ol>
<p>Currently, Kani does not support stack unwinding. This has some implications
regarding memory safety since programs sometimes rely on the unwinding logic to
ensure there is no resource leak or persistent data inconsistency. Check out
<a href="https://github.com/model-checking/kani/issues/692">this issue</a> for updates on
stack unwinding support.</p>
<h3 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized memory</a></h3>
<p>Reading uninitialized memory is
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#behavior-considered-undefined">considered undefined behavior</a> in Rust.
At the moment, Kani cannot detect if memory is uninitialized, but in practice
this is mitigated by the fact that all memory is initialized with
nondeterministic values.
Therefore, any code that depends on uninitialized data will exhibit nondeterministic behavior.
See <a href="https://github.com/model-checking/kani/issues/920">this issue</a> for more details.</p>
<h3 id="destructors"><a class="header" href="#destructors">Destructors</a></h3>
<p>At present, we are aware of some issues with destructors, in particular those
related to <a href="rust-feature-support.html#advanced-features">advanced features</a>.</p>
<h3 id="intrinsics"><a class="header" href="#intrinsics">Intrinsics</a></h3>
<p>Please refer to <a href="rust-feature-support/intrinsics.html">Intrinsics</a> for information
on the current support in Kani for Rust compiler intrinsics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intrinsics-1"><a class="header" href="#intrinsics-1">Intrinsics</a></h1>
<p>The table below tries to summarize the current support in Kani for Rust
compiler intrinsics. We define the level of support similar to how we
indicate <a href="rust-feature-support/../rust-feature-support.html">Rust feature support</a>:</p>
<ul>
<li><strong>Yes</strong>: The intrinsic is fully supported. We are not aware of any issue with it.</li>
<li><strong>Partial</strong>: The intrinsic is at least partially supported. We are aware of some issue with
with it.</li>
<li><strong>No</strong>: The intrinsic is not supported.</li>
</ul>
<p>In general, code generation for unsupported intrinsics follows the rule
described in <a href="rust-feature-support/../rust-feature-support.html#code-generation-for-unsupported-features">Rust feature support - Code generation for unsupported
features</a>.</p>
<table><thead><tr><th>Name</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>abort</td><td>Yes</td><td></td></tr>
<tr><td>add_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>arith_offset</td><td>No</td><td></td></tr>
<tr><td>assert_inhabited</td><td>Yes</td><td></td></tr>
<tr><td>assert_uninit_valid</td><td>Yes</td><td></td></tr>
<tr><td>assert_zero_valid</td><td>Yes</td><td></td></tr>
<tr><td>assume</td><td>Yes</td><td></td></tr>
<tr><td>atomic_and</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acq_failrelaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_failrelaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_failacq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_failrelaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acq_failrelaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_failrelaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_failacq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_failrelaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_unordered</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_acq</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_acqrel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_rel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_relaxed</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_acq</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_acqrel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_rel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_relaxed</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_unordered</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_acq</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_acqrel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_rel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_relaxed</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_acq</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_acqrel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_rel</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_relaxed</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_acq</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_rel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>blackbox</td><td>Yes</td><td></td></tr>
<tr><td>bitreverse</td><td>Yes</td><td></td></tr>
<tr><td>breakpoint</td><td>Yes</td><td></td></tr>
<tr><td>bswap</td><td>Yes</td><td></td></tr>
<tr><td>caller_location</td><td>No</td><td></td></tr>
<tr><td>ceilf32</td><td>No</td><td></td></tr>
<tr><td>ceilf64</td><td>No</td><td></td></tr>
<tr><td>copy</td><td>No</td><td></td></tr>
<tr><td>copy_nonoverlapping</td><td>No</td><td></td></tr>
<tr><td>copysignf32</td><td>No</td><td></td></tr>
<tr><td>copysignf64</td><td>No</td><td></td></tr>
<tr><td>cosf32</td><td>Yes</td><td></td></tr>
<tr><td>cosf64</td><td>Yes</td><td></td></tr>
<tr><td>ctlz</td><td>Yes</td><td></td></tr>
<tr><td>ctlz_nonzero</td><td>Yes</td><td></td></tr>
<tr><td>ctpop</td><td>Yes</td><td></td></tr>
<tr><td>cttz</td><td>Yes</td><td></td></tr>
<tr><td>cttz_nonzero</td><td>Yes</td><td></td></tr>
<tr><td>discriminant_value</td><td>Yes</td><td></td></tr>
<tr><td>drop_in_place</td><td>No</td><td></td></tr>
<tr><td>exact_div</td><td>Yes</td><td></td></tr>
<tr><td>exp2f32</td><td>No</td><td></td></tr>
<tr><td>exp2f64</td><td>No</td><td></td></tr>
<tr><td>expf32</td><td>No</td><td></td></tr>
<tr><td>expf64</td><td>No</td><td></td></tr>
<tr><td>fabsf32</td><td>Yes</td><td></td></tr>
<tr><td>fabsf64</td><td>Yes</td><td></td></tr>
<tr><td>fadd_fast</td><td>Yes</td><td></td></tr>
<tr><td>fdiv_fast</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/809">#809</a></td></tr>
<tr><td>float_to_int_unchecked</td><td>No</td><td></td></tr>
<tr><td>floorf32</td><td>No</td><td></td></tr>
<tr><td>floorf64</td><td>No</td><td></td></tr>
<tr><td>fmaf32</td><td>No</td><td></td></tr>
<tr><td>fmaf64</td><td>No</td><td></td></tr>
<tr><td>fmul_fast</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/809">#809</a></td></tr>
<tr><td>forget</td><td>Yes</td><td></td></tr>
<tr><td>frem_fast</td><td>No</td><td></td></tr>
<tr><td>fsub_fast</td><td>Yes</td><td></td></tr>
<tr><td>likely</td><td>Yes</td><td></td></tr>
<tr><td>log10f32</td><td>No</td><td></td></tr>
<tr><td>log10f64</td><td>No</td><td></td></tr>
<tr><td>log2f32</td><td>No</td><td></td></tr>
<tr><td>log2f64</td><td>No</td><td></td></tr>
<tr><td>logf32</td><td>No</td><td></td></tr>
<tr><td>logf64</td><td>No</td><td></td></tr>
<tr><td>maxnumf32</td><td>No</td><td></td></tr>
<tr><td>maxnumf64</td><td>No</td><td></td></tr>
<tr><td>min_align_of</td><td>Yes</td><td></td></tr>
<tr><td>min_align_of_val</td><td>Yes</td><td></td></tr>
<tr><td>minnumf32</td><td>No</td><td></td></tr>
<tr><td>minnumf64</td><td>No</td><td></td></tr>
<tr><td>move_val_init</td><td>No</td><td></td></tr>
<tr><td>mul_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>nearbyintf32</td><td>No</td><td></td></tr>
<tr><td>nearbyintf64</td><td>No</td><td></td></tr>
<tr><td>needs_drop</td><td>Yes</td><td></td></tr>
<tr><td>nontemporal_store</td><td>No</td><td></td></tr>
<tr><td>offset</td><td>Partial</td><td>Doesn't check <a href="https://doc.rust-lang.org/std/primitive.pointer.html#safety-2">all UB conditions</a></td></tr>
<tr><td>powf32</td><td>No</td><td></td></tr>
<tr><td>powf64</td><td>No</td><td></td></tr>
<tr><td>powif32</td><td>No</td><td></td></tr>
<tr><td>powif64</td><td>No</td><td></td></tr>
<tr><td>pref_align_of</td><td>Yes</td><td></td></tr>
<tr><td>prefetch_read_data</td><td>No</td><td></td></tr>
<tr><td>prefetch_read_instruction</td><td>No</td><td></td></tr>
<tr><td>prefetch_write_data</td><td>No</td><td></td></tr>
<tr><td>prefetch_write_instruction</td><td>No</td><td></td></tr>
<tr><td>ptr_guaranteed_eq</td><td>Yes</td><td></td></tr>
<tr><td>ptr_guaranteed_ne</td><td>Yes</td><td></td></tr>
<tr><td>ptr_offset_from</td><td>Partial</td><td>Doesn't check <a href="https://doc.rust-lang.org/std/primitive.pointer.html#safety-4">all UB conditions</a></td></tr>
<tr><td>raw_eq</td><td>Partial</td><td>Cannot detect <a href="rust-feature-support/intrinsics.html#uninitialized-memory">uninitialized memory</a></td></tr>
<tr><td>rintf32</td><td>No</td><td></td></tr>
<tr><td>rintf64</td><td>No</td><td></td></tr>
<tr><td>rotate_left</td><td>Yes</td><td></td></tr>
<tr><td>rotate_right</td><td>Yes</td><td></td></tr>
<tr><td>roundf32</td><td>No</td><td></td></tr>
<tr><td>roundf64</td><td>No</td><td></td></tr>
<tr><td>rustc_peek</td><td>No</td><td></td></tr>
<tr><td>saturating_add</td><td>Yes</td><td></td></tr>
<tr><td>saturating_sub</td><td>Yes</td><td></td></tr>
<tr><td>sinf32</td><td>Yes</td><td></td></tr>
<tr><td>sinf64</td><td>Yes</td><td></td></tr>
<tr><td>size_of</td><td>Yes</td><td></td></tr>
<tr><td>size_of_val</td><td>Yes</td><td></td></tr>
<tr><td>sqrtf32</td><td>No</td><td></td></tr>
<tr><td>sqrtf64</td><td>No</td><td></td></tr>
<tr><td>sub_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>transmute</td><td>Partial</td><td>Doesn't check <a href="https://doc.rust-lang.org/nomicon/transmutes.html">all UB conditions</a></td></tr>
<tr><td>truncf32</td><td>No</td><td></td></tr>
<tr><td>truncf64</td><td>No</td><td></td></tr>
<tr><td>try</td><td>No</td><td><a href="https://github.com/model-checking/kani/issues/267">#267</a></td></tr>
<tr><td>type_id</td><td>Yes</td><td></td></tr>
<tr><td>type_name</td><td>Yes</td><td></td></tr>
<tr><td>unaligned_volatile_load</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>unaligned_volatile_store</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>unchecked_add</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_div</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_mul</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_rem</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_shl</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_shr</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_sub</td><td>Yes</td><td></td></tr>
<tr><td>unlikely</td><td>Yes</td><td></td></tr>
<tr><td>unreachable</td><td>Yes</td><td></td></tr>
<tr><td>variant_count</td><td>No</td><td></td></tr>
<tr><td>volatile_copy_memory</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_copy_nonoverlapping_memory</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_load</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_set_memory</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_store</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>wrapping_add</td><td>Yes</td><td></td></tr>
<tr><td>wrapping_mul</td><td>Yes</td><td></td></tr>
<tr><td>wrapping_sub</td><td>Yes</td><td></td></tr>
<tr><td>write_bytes</td><td>Yes</td><td></td></tr>
</tbody></table>
<h4 id="atomics"><a class="header" href="#atomics">Atomics</a></h4>
<p>All atomic intrinsics are compiled as an atomic block where the operation is
performed. But as noted in <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a>, Kani support for
concurrent verification is limited and not used by default. Verification on code
containing atomic intrinsics should not be trusted given that Kani assumes the
code to be sequential.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<p>In general, unstable Rust features are out of scope and any support
for them available in Kani should be considered unstable as well.</p>
<p>The following are exampels of unstable features that are not supported
in Kani:</p>
<ul>
<li>Generators</li>
<li>C-variadics</li>
<li><code>repr(simd)</code> and related intrinsics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overrides"><a class="header" href="#overrides">Overrides</a></h1>
<p>As explained in <a href="./tool-comparison.html#comparison-with-other-tools">Comparison with other
tools</a>, Kani is based on a
technique called model checking, which verifies a program without actually
executing it. It does so through encoding the program and analyzing the encoded
version. The encoding process often requires &quot;modeling&quot; some of the library
functions to make them suitable for analysis. Typical examples of functionality
that requires modeling are system calls and I/O operations. In some cases, Kani
performs such encoding through overriding some of the definitions in the Rust
standard library.</p>
<p>The following table lists some of the symbols that Kani
overrides and a description of their behavior compared to the <code>std</code> versions:</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assert</code>, <code>assert_eq</code>, and <code>assert_ne</code> macros</td><td>Skips string formatting code, generates a more informative message and performs some instrumentation</td></tr>
<tr><td><code>debug_assert</code>, <code>debug_assert_eq</code>, and <code>debug_assert_ne</code> macros</td><td>Rewrites as equivalent <code>assert*</code> macro</td></tr>
<tr><td><code>print</code>, <code>eprint</code>, <code>println</code>, and <code>eprintln</code> macros</td><td>Skips string formatting and I/O operations</td></tr>
<tr><td><code>unreachable</code> macro</td><td>Skips string formatting and invokes <code>panic!()</code></td></tr>
<tr><td><code>std::process::{abort, exit}</code> functions</td><td>Invokes <code>panic!()</code> to abort the execution</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
